<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>sjkim2322.github.io/logbook/</title>
   
   <link>http://sjkim2322.github.io/logbook/</link>
   <description></description>
   <language>en-uk</language>
   <managingEditor> SeongJin Kim</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Prototype</title>
	  <link>/logbook//javascript-prototype</link>
	  <author>SeongJin Kim</author>
	  <pubDate>2017-09-07T01:00:00+09:00</pubDate>
	  <guid>/logbook//javascript-prototype</guid>
	  <description><![CDATA[
	     <h3 id="javascript의-class">JavaScript의 Class</h3>
<p>기본적으로 자바스크립트에서는 Class라는 개념이 없다. <br />
ES6 스펙에 공식적으로 Class를 사용할 수 있는 문법이 추가 되었다. <br />
하지만 여기서 사용하는 Class의 문법이 java와 같은 언어에서 동작하는 Class와 엄연히 다르다는 것을 알아야한다.</p>

<h3 id="new">new</h3>
<p>java에서는 new 키워드를 통해서 클래스의 인스턴스를 생성한다.</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//java   
Person person = new Person();
</code></pre>
</div>
<p>javascript에서도 new라는 키워드는 존재하며 사용하는 방식 또한 비슷하다.</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//javascript   
var person = new Person();
</code></pre>
</div>
<p>여기서 다른 점은 Type과 Person이 클래스이냐 함수이냐의 차이이다. <br />
javascript에서 함수가 하는 역할은 java와 다르다. <br />
일반적으로 java와 같은 언어에서 함수의 역할은 “일련의 처리를 하는 로직이 담긴 Block” 정도가 되겠다. <br />
하지만 javascript에서는 위의 역할을 포함함과 동시에 <strong>“새로운 객체를 생성하는 생성자”</strong> 의 역할도 담당한다.<br />
다음 코드를 보자.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function test() {
    this.name = "Kim";
}
</code></pre>
</div>
<p>다음과 같은 코드를 new 키워드를 이용하여 생성자 함수로써 사용할 수 있는데 실행하면 다음의 작업들이 순차적으로 실행된다.</p>

<ol>
  <li>빈 오브젝트 생성</li>
  <li>실행된 함수의 this value를 1번에서 생성한 빈 오브젝트에 바인딩</li>
  <li>생성자함수의 prototype Object를 1번에서 생성한 빈오브젝트의 prototype으로 설정</li>
  <li>생성자 함수의 내부 실행</li>
  <li>특별히 명시된 return 문이 없는 경우 1번에서 생성한 오브젝트를 Return</li>
</ol>

<h3 id="prototype">Prototype</h3>
<p>그런데 new 키워드를 통해 함수를 생성자로써 사용하는 것과 Prototype이랑 무슨 관계가 있는 것일까? <br />
java와 같은 언어에 존재하는 상속과 같은 개념을 javascript에서는 prototype을 이용하여 흉내를 낼 수 있다. <br />
앞서 얘기 한 것처럼 javscript의 함수의 역할은 새로운 객체를 생성하는 생성자 역할을 포함한다. <br />
여기서 추가적으로 더 알아야할 것은 javascript의 객체는 반드시 자신의 부모역할을 하는 객체와 연결이 되어있다. <br />
이러한 객체를 <strong>ProtoType객체</strong> 라고 한다.</p>

<p>여기서 크롬 브라우저의 개발자 도구를 이용해서 객체의 내부를 살펴보면 의미의 혼돈이 생기게 된다. <br />
그럴 수 밖에 없는 이유는 생성자역할을 하는 함수의 경우 함수의 자체적인 프로퍼티로 다음과 같은 2개의 프로퍼티를 갖는다.</p>

<ol>
  <li>prototype</li>
  <li>__proto__</li>
</ol>

<p>앞서 얘기한 ProtoType객체에 해당하는 부분은 __proto__에 해당한다. <br />
prototype 프로퍼티는 일반 객체는 갖고 있지 않은 프로퍼티로, 생성자 자격이 있는 함수가 새로운 객체를 생성할 때  <br />
그객체의 Prototype 객체에 연결 시켜주기 위한 object를 가리키고 있는 프로퍼티이다.</p>

<p>javscript의 모든객체는 prototype을 가지고 있고 어떤객체의 prototype또한 prototype을 가지고 있다. <br />
즉, prototype은 chaining 되며 최종 객체인 Object까지 올라 갈 수있다.  <br />
이 chaining을 통해서 객체 내부에 존재하지 않는 변수나 함수 일지라도 prototype에 있는 경우 이를 사용할 수 있게 된다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Javascript Hoisting 과 Execution Context</title>
	  <link>/logbook//Javascript-Hoisting</link>
	  <author>SeongJin Kim</author>
	  <pubDate>2017-09-03T07:30:00+09:00</pubDate>
	  <guid>/logbook//Javascript-Hoisting</guid>
	  <description><![CDATA[
	     <p><br />
 사실 본인은 자바스크립트가 꽤나 근본이 없는 언어라고 생각했다. <br />
<del>아무렇게 작성해도 알아먹으니까.</del> <br />
특히나 Hoisting가 관련된 부분은 꽤 골머리를 썩혔다. 잘동작했던 코드였는데 잘되다가 안되다가..
그 당시에는 괜히 자바스크립트를 탓했었다. <br />
하지만 그러한 이유는 본인에 무지함에 있었다는 것을 Hoisting을 이해한 뒤로 알게 되었다. <br />
이 글을 읽고 내글의 제목에 Execution Context를 추가했다. Hoisting만 얘기하기에는 설명이 부족할 것같다.
<a href="http://poiemaweb.com/js-execution-context">한글로 제일 잘 설명된 Execution Context 관련 글</a>이라 생각한다.</p>

<h4 id="hoisting의-오해">Hoisting의 오해</h4>

<h5 id="1">1.</h5>
<p>Hoist 라는 단어의 뜻(들어올리다)이 그렇듯, 특정 코드를 가장위로 들어올려주는 것으로 생각한다.
하지만 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting">Mozila</a>에 쓰여진 바로는 다음과 같다.</p>

<ul>
  <li>hoisting teaches that variable and function declarations are physically moved to the top of your coding, 
but this is not what happens at all. What does happen is that variable and function declarations are put into memory during the compile phase,
but stays exactly where you typed it in your coding.</li>
</ul>

<p>즉, Hoisting이라는 것은 우리가 작성한 코드의 물리적 위치를 변경하지 않는다. 단순히 선언식을 먼저 가지고 있는 것일 뿐</p>

<h5 id="2">2.</h5>
<p>Hoisting이라는 것이 자바스크립트가 사용하는 특별한 기능을 지칭하는 말이 아니다. <br />
자바스크립트가 코드를 읽는 방식을 이해한다면 지극히 당연한 기능이지만 코드를 작성하는 입장(Java나 C를 먼저 접한사람이라면)에서는 꽤나 어색하게 느껴진다.
그렇다면 도대체 Hoisting이 뭘까? 자세히 알아보자</p>

<h4 id="실행-컨텍스트">실행 컨텍스트</h4>
<p>사실 Hoisting 뿐만 아니라 클로저,Scope 더 나아가 ES6의 Generator 까지 실행 컨텍스트를 이해하면 모든 의문이 풀린다.
앞에서 얘기한 링크를 많이 참고하였다.       <br />
실행 컨텍스트(이하 EC)란 자바스크립트 코드를 실제로 <strong>실행 시키기 전</strong>에 실행에 필요한 정보를 담고 있는 객체이다.    <br />
최초 글로벌 EC를 필두로 함수가 호출될때마다 함수EC가 스택에 차례로 쌓이게 된다.       <br />
Active Context(현재 활성화된 컨텍스트)는 모든 시점에서 정확히 1개이다. =&gt; 엔진 콜스택의 최상단        <br />
<u>함수 종료시 해당함수의 EC는 파기되고 스택에서도 사라진다.</u>    <br />
그리고 해당함수를 호출한 컨텍스트가 Active Context가 된다. <br />
ES6에 추가된 Generator함수의 경우 위의 밑줄 친 문장은 예외가 된다.    <br />
Yield를 통해 함수의 컨텍스트를 빠져나가게 되는데 이 때 Generator함수의 EC는 파기 되지 않고 현재 상태를 기억하고 있다.      <br />
자세한 내용은 <a href="https://www.ecma-international.org/ecma-262/6.0/#sec-execution-contexts">ECMA 명세</a>를 다시한번 읽어봐야할 듯하다. <br />
<del>한번 읽어봤는데 잘모르겟다 영어를못해서..</del></p>

<blockquote>
  <p>앞서 얘기했듯이 EC는 객체이다. 객체이기 때문에 다음 3가지를 Property로 갖는다.</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>//ExecutionContext
{
    VariableObject : "",
    ScopeChain : "",
    thisValue :""
}
</code></pre>
</div>

<h5 id="1variable-object-이하-vo">1.Variable Object (이하 VO)</h5>

<blockquote>
  <p>실행에 필요한 실제 변수들을 담고 있는 객체를 가리키는 객체이다. <br />
최초에 생성되는 전역 EC의 경우 VO프로퍼티는 전역객체(Global Object 이하 GO)를 가리킨다.     <br />
GO는 전역으로 선언된 함수와 변수를 프로퍼티로 갖는 객체이다. <br />
GO의 경우 모든 Scope에서 접근이 가능하다(Global 객체이므로) <br />
그래서 Built-in object(Math, String, Array 등)와 BOM, DOM이 Set 되어있다.
그리고 전역 Scope에 있는 함수와 변수 선언을 포함하고 있다.</p>
</blockquote>

<blockquote>
  <p>전역코드 뿐만 아니라 함수가 자바스크립트의 CallStack에 들어올때(함수가 호출되어 실행될 때) 또한 EC가 하나생성되고 VO가 생성된다. <br />
함수의 경우, 전역 EC와 달리 VO는 전역객체를 가리키지 않고 Activation Object를 가리키게 된다.
Activation Object의 경우 앞에서 얘기한 GO와 거의 동일하지만 <br />
<u>Built-in object를 포함한 전역객체만의 프로퍼티들</u>을 포함하지 않고 <br />
대신 함수의 인자를 배열형태로 담고 있는 <u>Argument Object</u>가 추가된다.
Argument Object는 함수를 선언시 설정한 파라미터들과는 별개로 보는게 맞는 것같다.</p>
  <div class="highlighter-rouge"><pre class="highlight"><code>function foo(var1,var2,var3) {
    ...
}
foo(1,2,3,4); // thisLine
</code></pre>
  </div>
  <p>다음과 같은 코드의 경우 <code class="highlighter-rouge">thisLine</code> 에서 함수가 callStack에 들어가게 되고 EC가 생성되는데 <br />
함수가 선언될 때는 파라미터를 총 3개를 받지만 호출시에는 총 4개의 인자를 넘겨준다. <br />
이런 경우, 자바같은 경우는 컴파일 에러가 나는 것으로 알고 있지만 <br />
자바스크립트의 경우 그대로 실행되며 여기서 EC가 생성되고 AO에 Argument Object가 생성될때 <br />
그 배열의 길이는 총 4개가 된다. 물론 초기에 선언해둔 변수에 Mapping되는 것은 1,2,3뿐이지만 <br />
AO에는 생성이 되었기 때문에 arguments 오브젝트에 접근해서 값을 사용할 수 있다.
AO에 Argument Object가 생성된 이후로는 GO와 동일한 형태로 현재 Scope에 새롭게 추가된 변수,함수 선언을 AO에 담는다.</p>
</blockquote>

<h5 id="2scopechain">2.ScopeChain</h5>
<blockquote>
  <p>자바나 C를 먼저 공부했던 본인의 입장에서는 ScopeChain은 너무나도 당연한 것이 였지만 <br />
자바스크립트에서는 ScopeChain의 열할이 단순히 상위 스코프를 연결해주는것에서 그치지 않는다는 것이다.
기본적으로 ScopeChain 프로퍼티는 배열이고, 0 번째 Index에서는 현재 EC에서 최초로 생성된 AO를 가리킨다. <br />
1번째 Index는 현재 EC의 상위 컨텍스트에 있는 EC의 AO를 가리킨다. <br />
이런식으로 마지막에는 전역 EC의 GO까지 배열에 담기게 된다. <br />
이러한 ScopeChain 때문에 현재 Scope의 상위에 있는 모든 변수와 함수들에게서 접근을 할 수 있게 된다. <br />
즉, 변수와 함수의 호출이 실행될 경우 그 이름과 일치하는 프로퍼티를 ScopeChain의 0번째 index에서 부터 차례대로 <br />
GO까지 탐색을 하는 과정을 거친다. <br />
(개인적인 생각으로는 EC를 생성하는 시점에 컨텍스트를 타고 타고 올라가는 과정을 거치지는 않을것같다. <br />
현재 AO를 0번째 인덱스에 담고 그이후로는 상위컨텍스트의 ScopeChain을 그대로 덮어쓰지 않을까 싶다.)
또, 이 ScopeChain은 [[Scope]]라는 프로퍼티로 접근이 가능하다.</p>
</blockquote>

<h5 id="3thisvalue">3.thisValue</h5>
<blockquote>
  <p>우리가 코드를 작성하면서 this라는 변수를 사용할 수 있었던 이유는 바로 EC가 this라는 프로퍼티를 생성하기 때문이다. <br />
this의 값은 함수의 호출패턴에 의해 결정된다고한다.(???)</p>
</blockquote>

<p>그런데 왜 본인은 Hoisting을 이야기하다가 갑자기 실행 컨텍스트를 이야기하고 있는가? <br />
사실 앞에서도 얘기 한 것처럼 Hoisting이라는 것은 뭔가 특별한 기능을 뜻하지 않는다고 했다.
단순히 실행컨텍스트의 동작방식을 이해하게 된다면 Hoisting뿐만 아니라 클로저도 이해를 할 수 있다.
그렇다면 EC가 위에 언급한 3개의 프로퍼티를 가지고 어떤식으로 동작하는지 알아보자.</p>

<h4 id="실행컨텍스트의-생성과-동작-방식">실행컨텍스트의 생성과 동작 방식</h4>
<p>실행 컨텍스트는 script코드가 최초에 실행될 때 처음으로 한개 생성된다. <br />
브라우저의 경우 여기서 생성된 전역 컨텍스트는 함수가 종료되었을때 파기되는 다른 EC와달리 페이지가 전환되기 전까지 살아 있다.
앞서 얘기한 것처럼 전역 컨텍스트의 경우 VO에 매핑되는 Object가 다른함수들과 달리 Global Object가 매핑된다고 하였지만
우리가 작성한 코드가 Window이라는 모든 코드를 포함하고 있는 큰함수가 덮고 있다고 생각하면 일반적인 함수의 EC와 같다. <br />
즉, Global Object는 Window이라는 모든 코드를 포함하는 함수의 Activation Object이다.</p>

<p>실행컨텍스트가 동작하는 순서는 다음과 같다.</p>
<h5 id="1-비어있는-activation-object-생성">1. <strong>비어있는</strong> Activation Object 생성</h5>
<h5 id="2-scopechain-생성-및-초기화">2. ScopeChain 생성 및 초기화</h5>
<h5 id="3-variable-instantiation-실행">3. Variable Instantiation 실행</h5>
<h5 id="4-this-value-결정">4. This value 결정</h5>

<p>맨위에 언급한 글에서는 ScopeChain 생성이 가장 먼저로 언급되어 있지만 그전에 빈 AO의 생성이 이루어져야 한다.
빈 AO를 생성하는 것은 실행컨텍스트의 열할이 아니므로 언급이 안된 것 같지만 이해를 위해 첫번째에 생성이 된다고 작성하였다.</p>

<h5 id="1비어있는-activation-object-생성">1.<strong>비어있는</strong> Activation Object 생성</h5>
<blockquote>
  <p>여기서 중요한 것은 <strong>비어있는</strong> 이다. <br />
추후 AO에 모든 변수,함수 선언들이 담길예정이지만 초기에는 비어있는 상태로 생성이 되게 된다. <br />
하지만 Global인 경우 완전히 비어있는 것은 아니고 위에 얘기한 것처럼 Built in Object를 포함한 것들이 생성되어 들어있다. <br />
함수 EC의 Activation Object의 경우에도 완벽히 비어있지는 않다. 함수의 EC가 생성되는 시점은 그 함수가 호출된 시점이므로 <br />
여기서 arguments객체가 생성된다. 함수에 전달된 인수가 하나도없을지라도 arguments객체는 생성된다.(이객체의 property로 callee,symbol,length 등이 생성된다.) <br />
즉, “비어있다”라는 의미는 곧 실행될 Variable Instantiation이 실행되지 않았다는 정도로 이해하는 것이 좋을 듯하다.</p>
</blockquote>

<h5 id="2scopechain-생성-및-초기화">2.ScopeChain 생성 및 초기화</h5>
<blockquote>
  <p>ScopeChain의 생성이 이 시점에서 이루어지는 것은 꽤나 중요하게 생각해야할 부분이다.
함수가 호출되기 전에, 심지어는 3번의 Variable Instantiation이 수행되기 전에 <br />
ScopeChain이 생성되고 초기화가 일어난다는 것은 <br />
어떤 Scope(함수이거나 글로벌이거나)의 코드들이 실행되기 전에 그 Scope에 접근할 수 있는 범위가 결정된다는 얘기이다.
쉽게 코드로 예를 들어보자.
<strong><a href="https://www.zerocho.com/category/Javascript/post/5741d96d094da4986bc950a0">이 글</a>의 코드를 살짝 수정하였습니다.</strong></p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>var name = 'global';
function wow() { 
  console.log(name); // "global";
}
function say () {
  var name = 'inner';
  console.log(name); // "inner"
  wow();
}
say();
</code></pre>
</div>
<blockquote>
  <p>지극히 당연한 얘기일 수도 있겠지만 위 코드에서 wow함수 내부의 name 변수가 전역의 “global”인 것은 <br />
ScopeChain이 함수가 호출되는 시점이 아닌 생성하는 시점에 형성이 되었기 때문에 wow함수의 ScopeChain에는 <br />
say함수의 VO가 없다.(say함수안에서 단순히 wow함수를 호출만 하였으므로)</p>
</blockquote>

<blockquote>
  <p>다시 ScopeChain 얘기로 돌아와서 1번에서 생성한 AO를 ScopeChain의 0번째에 할당한다. <br />
그리고 현재 EC가 실행되기 전에 그전 컨텍스트에 생성 되있던 VO의 [[Scope]]프로퍼티를 현재 EC의 ScopeChain을 1번째 부터 차례로 복사한다.
이로써 현재 EC가 담당하고 있는 스코프가 접근할 수 있는 ScopeChain이 형성된다.</p>
</blockquote>

<h5 id="3-variable-instantiation-실행-1">3. Variable Instantiation 실행</h5>
<blockquote>
  <p>이 단계에서는 전단계에서 이야기한 <strong>비어있는</strong> VO에 프로퍼티와 그에 해당하는 값을 채워주는 작업을 하게 된다. <br />
ScopeChain을 이해했다면 특정 Scope에서 접근가능한 VO가 하나가 아니라는 것을 이해하였을 것이다. <br />
외부에 있는 VO들의 경우 ScopeChain을 통해서 접근이 가능하게 되었고 그러한 VO들은 이미 지금 얘기하고자 하는 3단계 작업이 끝난 상태의 VO이다. <br />
이단계의 경우도 동작하는 순서가 있는데 다음과 같다.</p>
</blockquote>

<h5 id="1-formal-parameter-초기화">1. formal Parameter 초기화</h5>
<h5 id="2-함수선언식-초기화">2. 함수선언식 초기화</h5>
<h5 id="3-변수선언식-초기화">3. 변수선언식 초기화</h5>

<p><br /></p>

<h5 id="1-formal-parameter-초기화-1">1. formal Parameter 초기화</h5>
<blockquote>
  <p>실행 컨텍스트의 첫번째 단계인 비어있는 Activation Object생성단계에서 함수 컨택스트의 경우 <br />
arguments 객체에 인수들이 들어간다고 하였다. <br />
하지만 arguments에 들어가는 인수들은 실제 parameter에 해당하는 변수의 이름과 Mapping이 되지않은 상태이다. <br />
즉, 실제 파라미터 변수의 이름으로 AO에 프로퍼티를 추가하고 그에 대한 값은 arguments에 있는 인수의 값을 할당하는 단계가 <br />
formal Parameter를 초기화 하는 단계이다.</p>
</blockquote>

<h5 id="2-함수선언식-초기화-1">2. 함수선언식 초기화</h5>
<blockquote>
  <p>formal Parameter 초기화가 끝나게 되면 함수선언식에 대한 초기화가 실행된다. <br />
위의 문장을 다른 방식으로 얘기하면 다음과 같다. <br />
“함수선언식을 호이스팅한다.” <br />
글의 도입부에서 얘기한 것처럼 호이스팅은 특별한 기능을 이야기하는 것이 아니다. <br />
단순히 실행컨텍스트가 동작하는 순서일 뿐이다. 
EC가 Cover하는 Block 내부에 있는 코드들 중에서 함수선언식들만을 골라서 AO의 프로퍼티에는 함수의 이름을, <br />
그에 해당하는 값으로는 해당 함수의 Function Object를 할당한다. <br />
추가적으로 Function Object또한 Object이므로 그의 Property로 “[[Scope]]”를 만들고 이 것은 현재 EC의 ScopeChain을 가리키도록 한다. <br />
그렇다면 함수선언식이란 무엇일까? 코드로 살펴보자.</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>function foo() {
    ...
}

var bar = function() {
    ...
}

(function iife() {
    ...
})();
</code></pre>
</div>

<blockquote>
  <p>결과적으로 살펴보면 foo와 bar,iife 모두 함수임은 모두가 알고 있을 것이다. <br />
하지만 여기서 함수 선언식에 해당하는 부분은 foo만 해당하게 된다. <br />
bar와 iife의 경우 함수 표현식이라고 얘기한다. <br />
개인적인 생각으로는 bar의 경우는 함수표현식이라는 표현보다 오히려 변수에 값을 할당하는 것이라고 보는 편이 맞는것 같다. <br />
즉, Variable Instantiation을 하는 과정에서(코드가 실행되기 전) 함수의 선언식에 해당하는 부분이 먼저 AO에 올라가게 되므로 <br />
이 것은 마치 우리가 작성한 코드자체가 맨 위로 들어올려진 것처럼 생각하게 된다. <br />
이것을 호이스팅이라고한다.</p>
</blockquote>

<h5 id="3-변수선언식-초기화-1">3. 변수선언식 초기화</h5>
<blockquote>
  <p>변수선언식의 경우에도 전반적으로 함수선언식을 초기화하는 과정과 동일하다. <br />
하지만 여기서 <strong>초기화</strong>라는 의미를 혼동하지 말아야 한다. <br />
흔히 초기화의 의미를 “변수의 선언과 동시에 값을 할당하는 것” 이라고 생각한다. <br />
물론 틀린 말은 아닌 것이라 생각한다. <br />
하지만 실행 컨텍스트 관점에서의 변수의 초기화의 의미는 조금 다르다. <br />
실제 코드 작성 시 변수의 선언과 그 변수에 값을 할당하는 과정을 한 줄로 작성할 수 있기 때문에 <br />
의미의 혼동이 오는 듯 하다. <br />
하지만 내부적으로는 변수의 선언과 변수에 원하는 값을 할당하는 과정사이에 <strong>변수의 값을 “undefined”로 초기화 하는 과정이 있다.</strong> <br />
실행 컨텍스트의 관점에서 변수선언식의 초기화는 바로 변수의 값을 “undefined”로 초기화하는 것을 이야기한다. <br />
코드로 살펴보자.</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>console.log(a);
var a = 1;
</code></pre>
</div>
<blockquote>
  <p>위 코드의 실행 결과는 “undefined”이다. <br />
만약 변수선언식이 Hoisting 되지 않았다면 “a is not defined” 라는 Reference Error를 출력했을테지만 그렇지 않았다는 것은 a 변수가 호이스팅되었고 <br />
초기화 되었다는 것을 의미한다. <br />
하지만 초기화는 우리가 생각하는 “1”이라는 값을 할당하는 개념의 초기화가 아닌 “undefined”라는 값을 할당하는 초기화이기 때문에 <br />
Console에는 “undefined”가 찍히게 된다.  <br />
함수선언식 초기화 부분에서 다뤘던 bar함수의 경우에도 엄밀히 따지면 호이스팅이 된다고 할 수 있다. <br />
단지 함수 호이스팅이 아니라 bar라는 변수를 undefined 형태로 호이스팅 하였기 때문에 함수자체는 호이스팅이 되지 않는다.</p>
</blockquote>

<h5 id="4-this-value-결정-1">4. This value 결정</h5>
<blockquote>
  <p>Variable Instantiation 이 끝나게 되면 EC내부에서 사용될 this변수에 값을 할당하게 된다. <br />
this에 대해서는 따로 얘기가 필요하다고 생각 되는 부분이므로 ~<del>아직잘몰라서가아니고</del>~ <br />
전역 컨텍스트의 경우 전역객체를, 그리고 내부함수의 경우에도 전역객체를 가리킨다는 것 정도로만 이야기 하겠다.
<a href="http://poiemaweb.com/js-this">참고 링크</a></p>
</blockquote>

<h3 id="클로저">클로저</h3>
<blockquote>
  <p>위에 얘기한 내용을 어느정도 이해했다면 클로저가 동작하는 이유를 이해하는 것은 상당히 쉬워진다. <br />
사실 본인도 클로저가 무엇인지 알고 이를 활용해서 모듈패턴을 적용시킬 수 있다는 것 까지 알고 있다. <br />
하지만 도대체 어떻게 함수가 종료되어 콜 스택에서 빠져나간 뒤에도 해당 스코프에 있는 변수들에 접근할 수 있는지는 도저히 이해할 수 없었다. <br />
하지만 실행 컨텍스트의 관점에서 생각해보면 의외로 간단하다. <br />
앞에서도 얘기한 것처럼 어떤 함수가 실행이 종료되면 스택에 생성되었던 EC가 스택에서 빠지게 된다. <br />
하지만 그 함수 내부에 있던 다른 함수가 외부로 노출이 된다면 그 함수는 부모함수의 수명이 다한 뒤에도 부모함수의 Scope를 접근 할 수 있다는 것이 클로저의 기본 개념이다. <br />
함수의 실행이 완료되면 스택에서 EC가 빠지는 것은 명백한 FACT이다. <br />
하지만 EC는 파기 되지만 EC가 가리키고 있던 AO의 경우에는 조금다르다. <br />
이미 클로저로써 외부로 노출된 자식함수의 EC의 ScopeChain은 부모함수의 AO를 가지고 있을 것이다. <br />
이 경우 자식함수가 유효한 동안은 부모함수의 AO가 삭제되지 않는 형태가 되는데 <br />
이것이 바로 클로저가 우리가 생각했던대로 동작하는 이유라고 할 수 있다. <br />
그리고 부모함수의 AO가 사본형태의 AO가아닌 실제 AO를 그대로 가리키고 있으므로 클로저를 여러번 사용해여 부모함수의 AO에 있던 변수의 값을 지속적으로 증가시키는 등의 작업이 가능하다.</p>
</blockquote>

	  ]]></description>
	</item>


</channel>
</rss>
