<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>sjkim2322.github.io/logbook/</title>
   
   <link>http://sjkim2322.github.io/logbook/</link>
   <description></description>
   <language>en-uk</language>
   <managingEditor> SeongJin Kim</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>MessageConverter</title>
	  <link>/logbook//Spring-MessageConverter</link>
	  <author>SeongJin Kim</author>
	  <pubDate>2017-09-06T00:00:00+09:00</pubDate>
	  <guid>/logbook//Spring-MessageConverter</guid>
	  <description><![CDATA[
	     <h4 id="의문점">의문점</h4>
<p>Spring을 이용해서 Web Application개발을 하다보면 자연스럽게 REST API를 접하게 되고 <br />
 굳이 REST API를 사용하지 않더라도 클라이언트 단에서 XmlHttpRequest를 기반으로하는 Jquery의 Ajax 등을 이용해<br />
 화면전환없이 Data만을 요청하는 경우가 생긴다.</p>

<p>이러한 경우가 없다면 Spring에서 ViewResolver를 이용해서 컨트롤러의 return 값을 viewResolver를 거쳐 <br />
 원하는 페이지를 Response하는 형태가 일반적이다.</p>

<p>페이지 형태(html)의 Response가 아닌 Data만을 Response하고자 하는 경우 구현하는 방법은 생각보다 너무 쉽다.
 컨트롤러의 함수 위에 <code class="highlighter-rouge">@ResponseBody</code> 라는 어노테이션만 명시해주면 함수의 Return 자체가 Response의 Body로 들어가게 된다.
 즉, ViewResolver를 거쳐 서버의 Resource내부의 html파일(jsp 인경우도 있고)을 찾는 과정이 생략된다.
 코드로 살펴보자.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    @GetMapping("/{categoryId}/products")
    @ResponseBody
    public List&lt;Product&gt; getProductsByCategoryId(@PathVariable Integer categoryId) {
        return productService.getByCategoryId(categoryId); // return List&lt;Product&gt;
    } 
</code></pre>
</div>
<p>위의 코드의 어노테이션에 ResponseBody 이 쓰여있으므로 이 함수의 return은 그대로 요청에대한 응답인 Response의 Body에 들어가게 된다.</p>

<p>여기서 본인은 의문점이 생겼다. <br />
java의 클래스형태은 Bean을 Response의 body에 담았는데 java의 형태 그대로 클라이언트에 전달될 리는 없을 테고  클라이언트로 결과를 전송하기 전에 <br />
무엇인가를 거쳐가는 듯한데 그것이 과연 무엇인가? 라는 의문이였다.</p>

<h4 id="예상">예상</h4>
<p>자바를 공부하면서 직렬화에 대해서 미약하게 나마 공부하였고 자바의 데이터가 자바의 외부로 빠져나갈 때는 반드시 <br />
직렬화되어 나간다고 들었던 기억이 났다. <br />
스프링에서도 마찬가지라고 생각했고 내 생각이 맞는지 인터넷을 뒤져보았다. <br />
찾은 내용은 다음과 같다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>It does not. When you return an instance from controller method annotated with @ResponseBody   
you might say that it is serialized to JSON for instance. But this kind of serialization is not the Java serialization which involves Serializable interface.   
@RequestBody and @ResponseBody annotations are handled by RequestResponseBodyMethodProcessor which uses HttpMessageConverter implementations to perform the conversion for example from object to JSON or from JSON to object.
When you look at the HttpMessageConverter interface there is a canRead method which has the following signature: boolean canRead(Class&lt;?&gt; clazz, MediaType mediaType); and as you can see it is not bound to only serializable classes using generics.
</code></pre>
</div>

<h4 id="결론">결론</h4>
<p>지난 포스팅에서도 잠시 언급한 RequestBody 어노테이션에서 얘기한 것처럼 Spring은 MessageConverter를 이용하여
클라이언트와 서버간 데이터를 주고받을 때 데이터의 format을 맞춰주는 것 같다.
messageConverter 인터페이스를 구현한 여러 구현체들이 서버가 실행될 때 로드가 되고, 컨트롤러의 함수들중 요청한 URI와 일치하는 <br />
함수에게 Request의 Body에 있는 내용들을 요청과 함께 넘어온 Content-type과 함께 Converting할 수 있는 converter구현체를 찾는다.
함수의 로직이 실행되고 ResponseBody를 통해서 Bean을 클라언트로 넘겨 줄 때도 클라이언트가 응답을 받고자하는 포맷을 확인하고 
Bean을 이형태로 Convert해줄 수 있는 구현체를 찾아 Converting을 한다.</p>

<p>사실, ajax 를 이용해서 json형태로 응답을 받고자할 때 자신이 응답으로 받고자 하는 format을 딱히 설정하지 않아도 잘 받을 수 있는 경우가 있는데 <br />
<a href="http://api.jquery.com/jquery.ajax/">jquery의 ajax에 관련한 document</a>를 참고하면 “Intelligent Guess”라고 설명되어 있다.
즉, 별도로 명시하지 않아도 어느정도는 format을 자체적으로 결정할 수 있다.</p>

<p>하지만 클라이언트와 서버간 데이터통신의 format에 대해 자세히 이해하고 원하는 정보들을 직접 입력하여 사용하는 것이 <br />
코드를 최적화는 시작 단계가 아닌가라고 생각한다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Spring Jdbc의 join과 Integer</title>
	  <link>/logbook//Spring-Join-Integer-Wiki</link>
	  <author>SeongJin Kim</author>
	  <pubDate>2017-09-05T08:00:00+09:00</pubDate>
	  <guid>/logbook//Spring-Join-Integer-Wiki</guid>
	  <description><![CDATA[
	     <p>Join과 Integer라니 글의 주제가 꽤나 Matching되지 않아 보인다.
하지만 본인이 개발하면서 저 2가지의 개념사이에 연결부분이 존재했고 그것에 대해 이야기하고자 한다.</p>

<p>Integer란 java의 int Type에 대한 WrapperClass로써 Primitive Type인 int형 변수를 Reference Type 즉, 클래스처럼 다루고자 할 때 사용한다. <br />
데이터베이스를 연동하는 웹 프로젝트의 경우 Integer Class가 자주 사용되는데 그 이유는 <strong>Null 값을 담을 수 있다.</strong> 라는 점에 있다.</p>

<p>JDBC를 이용하여 데이터베이스의 Datatype이 int 형인 데이터를 가져오는 쿼리문의 수행결과를 Java단으로 가져오는 경우를 생각해보자.
데이터베이스에서는 기본적으로 조건을 걸지 않는다면 모든 컬럼이 Null일 수 있다. <br />
그렇다면 Null인 int형 컬럼을 JDBC를 통해 가져와서 java의 int형 변수에 할당하려고 한다면 어떻게 될까? <br />
당연한 결과겠지만 Error가 나게 된다.</p>

<p>사실, 데이터베이스의 쿼리결과를 Mapping하는 Object의 경우 int형 변수들이 필요하다면 모두 Integer로 변환하면 <br />
간단하게 해결될 문제이지만 primitive type인 int변수를 쓸 수 있는 상황에서도 Wrapper클래스를 사용한다면 리소스를 낭비하는 꼴이 된다. <br />
그렇기 때문에 Null값이 할당될 여지가 없는 경우에는 primitive type을 사용하는 것이 바람직하다. <br />
예를 들면 데이터베이스의 테이블에서 Primary key로 사용되는 컬럼의 경우 기본키는 무조건 Not null 속성을 가지고 있기 때문에 <br />
이를 java단에서 Mapping하는 변수의 경우에도 primitive type을 사용하여도 문제가 없을 것이다. <br />
(물론 Application 내부의 로직 단위에서 이 변수에 Null이 할당되는 경우 같은 에러가 나겠지만 이는 별게의 문제로 보는 것이 맞는것 같다.)</p>

<p>하지만 primary key로써 Not null을 보장받는 컬럼이라 할지라도 java단에 mapping될 때 Null값이 들어오는 경우가 있다.
바로 제목에서도 언급한 Join과 관련된 부분이다.</p>

<p>일반적인 Inner Join의 경우만을 생각한다면 잘 이해가 안될 수도 있다. 애초에 값이 있는 컬럼들이 Join을 한다고 해서 값이 비워질 수는 없는 노릇이기 때문이다. <br />
하지만 Outer Join의 경우를 생각해보자</p>

<p>상품 정보 테이블과 상품 상세 정보 테이블이 있다고하자. <br />
두 테이블 간에는 관계가 형성 되는데 상품 정보는 상품상세 정보를 갖지 않을 수도 있고 1개 가질 수 있다.</p>

<p>이러한 상황에서 상품정보와 상품 상세 정보를 Join한 결과를 JDBC를 통해서 가져온 뒤 Object에 Mapping을 한다고 가정하자. <br />
상품 상세 정보를 갖지 않는 상품 또한 쿼리의 결과에 포함되어야 하기 때문에 Inner Join을 사용한다면 원하는 결과를 얻을 수 없다. <br />
이를 해결하기 위해서는 상품 상세정보가 없는 상품정보 레코드들도 결과로 갖게 되는 Outer Join을 사용해야한다.</p>

<p>여기까지는 별다른 문제가 없다. <br />
하지만 문제는 java의 Object에 Mapping하는 순간 발생하게 된다. <br />
Outer Join을 이용하여 쿼리를 실행한 결과중 다음과 같은 결과가 있다고 생각해보자.</p>
<table>
<tr>
<th>상품정보.상품 ID</th><th>상품정보.상품명</th><th>상품상세정보.상세정보ID</th><th>상품상세정보.제작사</th>
</tr>
<tr>
<td>1</td><td>양말</td><td>11</td><td>양말공장</td>
</tr>
<tr>
<td>2</td><td>신발</td><td>null</td><td>null</td>
</tr>
</table>

<p>첫번째 row의 경우에는 아무 문제가 없다. 하지만 두번째 row의 경우 신발에 해당하는 상품상세 정보가 없었기 때문에 <br />
그자리에 null값이 결과로 반환되게 된다. JDBC에 연결된 Mapper는 이러한 정보들을 java의 Object에 Mapping을 시도하게 되고 <br />
앞에서 얘기 했던 것처럼 우리는 primary key는 Null일 수 없으므로 int형 변수로 선언을 해두었다. <br />
이러한 상황이 생기게 된다면 JDBC는 Error가 발생하게 되고 우리는 원하는 결과를 얻을 수가 없다.</p>

<p>Application이 동작하면서 사용하는 리소스를 최소화시키기 위해 primitive type을 사용하는 것은 좋지만 <br />
이러한 작업들을 예외없이 처리하기 위해서는 많은 경험이 필요하다는 것을 새삼 느끼게 해주었던 사례였다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Spring FrameWork Injection Type</title>
	  <link>/logbook//Spring-Injection-Type</link>
	  <author>SeongJin Kim</author>
	  <pubDate>2017-09-02T01:00:00+09:00</pubDate>
	  <guid>/logbook//Spring-Injection-Type</guid>
	  <description><![CDATA[
	     <h3 id="injection-종류">Injection 종류</h3>
<p><strong>가장 이해가 잘되었던 Post :</strong> <br />
<a href="http://vojtechruzicka.com/field-dependency-injection-considered-harmful/">Field Dependency Injection Considered Harmful</a></p>
<blockquote>
  <p>Spring이 Bean들을 Injection 하는 방법은 대표적으로 3개이다.</p>
  <ol>
    <li>Setter Injection</li>
    <li>Constructor Injection</li>
    <li>Field Injection</li>
  </ol>
</blockquote>

<blockquote>
  <p>그리고 Spring에서는 지원하지 않는 Injection 방식인 Interface를 활용한 방법이 있다고한다.
코드 예시는 다음과 같다.</p>
</blockquote>

<p>1.Setter Injection</p>
<div class="highlighter-rouge"><pre class="highlight"><code>class MyController {
     private MyService myservice;
     @Autowired
     public setMyservice(Myservice myservice) {
          this.myservice = myservice;
     }
}

</code></pre>
</div>
<p>2.Constructor Injection</p>
<div class="highlighter-rouge"><pre class="highlight"><code>class MyController {    
     private MyService myservice;
     @Autowired
     public MyController(Myservice myservice) {
          this.myservice = myservice;
     }
}

</code></pre>
</div>

<p>3.Field Injection</p>
<div class="highlighter-rouge"><pre class="highlight"><code>class MyController {
     @Autowired
     CategoryService categoryService;
}
</code></pre>
</div>

<blockquote>
  <p>성능상으로는 3가지 방법모드 같다고 판단 된다.
Bean이 Injection 되는 시점이 조금 씩다를뿐</p>
</blockquote>

<blockquote>
  <p>코드의 라인수로만 보면 Field Injection을 사용하는 것이 가장 간단하다.
하지만 Spring에서는 Field Injection사용을 지양할 것을 권유한다.
IntelliJ에서도 Field Injection을 사용하면 Warning Comment가 생긴다.</p>
</blockquote>

<blockquote>
  <p>인터넷을 뒤져봐도 Setter VS Constructor 와 관련된 내용이 많고 Field Injection은 거의 언급조차 되지 않는다.</p>
</blockquote>

<blockquote>
  <p>먼저 Setter와 Constructor Injection차이를 알아보자.</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>1. setter Injection in more readable than constructor injection in Spring configuration file usually applicationContext.xml .   
</code></pre>
</div>

<blockquote>
  <p>setter Injection의 경우 인젝션할 클래스가 함수명에 명시되기때문에 설정파일에서 더 직관적으로 읽을 수 있다
constructor의 경우 설정파일에서 인젝션을 명시한경우 실제 클래스파일을 봐야지만 생성자가 무엇을 주입하는지 알수 있다.
하지만 xml 형태의 설정파일뿐만아니라 Java기반으로 설정하는 방법도 있다. Java파일을 기반으로 설정한다면 Constructor를 통해서도 
쉽게 파악이 가능할 것같다.</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>2. one of the drawback of  setter injection is that it does not ensures dependency Injection. 
which means you may have an object with incomplete dependency. On other hand constructor Injection does not allow you to construct object, until your dependencies are ready.
</code></pre>
</div>

<blockquote>
  <p>Injection 시점과 관련된 이야기인듯하다. 먼저 자바에서 클래스가 만들어지는 시점(Bean이생성되는 시점)에 <code class="highlighter-rouge">New ClassName()</code>을 통해서 클래스의 Constructor가 실행된다.
즉, Constructor를 통해서 injection을 한다면 “Bean생성” == “외부 Bean Injection” 이 성립하게된다. 그렇기 때문에 Constructor Injection은 의존성을 주입하지 않고서는 Bean이 생성될 수 없으므로 
확실한 Injection을 보장한다. <br />
하지만 Setter Injection의 경우, 의존성을 주입받는 Bean의 생성과 이 Bean에 다른 Bean을 주입시키는 과정이 분리되게 된다.
먼저 의존성이 주입되지 않는 Bean을 생성한뒤 Setter함수를 통해서 의존성을 주입하게 된다. 
그렇기 때문에 이방법은 의존성이 주입됐다는 것을 보장할 수가 없다.</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>3. In other words, we can force a user of our class (again, this might be Spring but it could also be a unit test that instantiates your class directly) to instantiate it while passing in arguments.
</code></pre>
</div>

<blockquote>
  <p>이 말이 가장 중요한 말이 것 같다. 사실 1번과 2번이 잘 이해가 안되었었다. ‘어짜피 Spring이 결국에는 똑같은 결과를 내어주는데 이게 무슨 의미가 있는가?’라고 생각했다.
하지만 3번을 읽고 <code class="highlighter-rouge">POJO</code> 와 <code class="highlighter-rouge">Unit Test 에서의 Unit</code>이라는 것의 의미를 조금더 알게 되었다. 
스프링은 자바기반 Framework에 불과 하다. 즉 개발자가 작성한 코드와 Spring framework이 완전히 분리가 될 수 있어야한다.
진정한 UnitTest란 Framework에 의존하지 않는 상태에서 Test가 되야한다.</p>
</blockquote>

<p><strong>그렇기 때문에 Feild Injection을 사용한다면 개발자가 작성한 코드가 Spring의 구조에서 벗어나게된다면 Bean을 주입할 코드가 추가로 작성이 되어야한다.</strong></p>

<p>field에 어노테이션을 다는것만으로 Spring은 Injection을 해주지만 실제로는 외부에서 객체를 받는 함수가 존재해야한다.</p>

<p>사실 Spring의 성능상에 차이가 있는 줄알고 찾아봤지만 오히려 뭔가 OOP적인 느낌이 무엇인지 알게 되었다.</p>


	  ]]></description>
	</item>

	<item>
	  <title>Spring Controller의 Parameter Annotation</title>
	  <link>/logbook//Spring-Request-Parameter-Annotation</link>
	  <author>SeongJin Kim</author>
	  <pubDate>2017-09-02T01:00:00+09:00</pubDate>
	  <guid>/logbook//Spring-Request-Parameter-Annotation</guid>
	  <description><![CDATA[
	     <h3 id="controller의-parameter">Controller의 Parameter</h3>
<blockquote>
  <p>Controller클래스입장에서 URI요청에 대한 Entry Point (실제 Entry Point는 Controller이전에 수많은 것들을 거쳐오겟지만)는 
그안의 Method에서 시작된다. Method는 request로부터 Data를 취하기 위해서 파라미터를 선언하는데 이게 httpservletrequest부터 시작해서
너무도 많은 Data type이 있다. 단순히 일반 객체를 파라미터로 선언하고 Annotation을 통해 자동으로 들어간다.
어떻게 이게 가능할까? 또 각각 무슨차이가 있을까? 
코드를 보면 대략 이렇다.</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>//HttpServletRequest
public String method(HttpServletRequest request) {
   
}

//@RequestParam
public String method(@RequestParam("id") int id) {
   
}

//@ModelAttribute
public String method(@ModelAttribute Object myObject) {
   
}

//@ResquestBody
public String method(@ResquestBody Object myObject) {
   
}
//@pathvariable
@GetMapping("/{productId}")
public String method(@pathvariable int productId) {
   
}
</code></pre>
</div>
<blockquote>
  <p>먼저 <code class="highlighter-rouge">HttpServletRequest</code>부터 알아보자. <br />
Web에서 클라이언트로 받은 HTTP Request는 단순히 텍스트이다. <br />
서버의 구동환경에 따라서 WAS가 있을수도 있고 WebServer만 있을 수도 있지만 Servlet컨테이너를 포함하고 있는 WAS를 거칠 경우, <br />
ServletRequest인터페이스를 거쳐 HTTP프로토콜에 한해서 HttpServletRequest 인터페이스를 구현한 어떤 객체에 Request정보들이 Parsing되는 듯 하다. <br />
Spring을 거쳐 Controller클래스의 method에 도착했을때는 HttpServletRequest를 파라미터로 선언하게 되면 파싱된 Request정보를 사용할 수 있게 된다. <br />
하지만 Application을 개발하는 Layer에서 특정 Container가 만들어내는 객체를 바로사용하는 것을 지향한다고 한다. <br />
(사실 잘이해가 안되는 부분..)</p>
</blockquote>

<blockquote>
  <p>이후 다른 어노테이션들은 모두 HttpServletRequest를 이용하여 자동으로 일반객체에 파싱을 해주는 역할을 한다. <br />
RequestParam부터 알아보자.    <br />
이 어노테이션이 HTTP의 Get방식에서 QueryString을 취할 때만 사용하는 것으로 알고 있는 사람들이 많다.  <br />
본인도 그랬다. 하지만 이 어노테이션은 HTTP Method에 제한되지 않고 Request내부에서 어노테이션 뒤에 명시한 이름과 같은 name을 가지고 있는 
데이터를 찾아서 파싱해준다.  <br />
쉽게 얘기하면 클라이언트가 서버에게 Request를 보낼때 Content Type을 함께 보낸다.    <br />
Default 값은  <code class="highlighter-rouge">application/x-www-form-urlencoded</code>로 Get방식으로 보낼때 ? 뒤에 붙는 Format가 정확히 같다.
ex) <code class="highlighter-rouge">key=value&amp;key=value</code> <br />
RequestParam은 위와 같은 content type으로 넘어온 데이터들 중에서 Key값과 본인이 찾아야할값이 같은 value를 파싱해줄수 있다.</p>
</blockquote>

<blockquote>
  <p>그렇다면 왜 이 어노테이션을 Post방식에서는 자주 볼수 없는 걸까? 
기본적으로 Post방식은 form을 통해서 전송이 될 것이고 그 Content Type 또한  <code class="highlighter-rouge">application/x-www-form-urlencoded</code>으로 될텐데 말이다.
그 이유는 ModelAttribute 어노테이션에 있다고 본다. 예를 들어 다음과 같은 클래스가 있다고 생각해보자</p>
</blockquote>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
  
    <span class="c1">//getter, setter, constructor...  </span>
<span class="o">}</span>
</code></pre>
</div>

<blockquote>
  <p>클라이언트로 부터 id, name, age를 Post방식으로 받아오고 Content type은 Default일 경우 이를 받아내는 Controller의 함수는 다음과 같다.</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>public String method(@RequestParam("id") int id, 
                     @RequestParam("name") String name),
                     @RequestParam("age") int age)) {
   Member member = new Member();
   member.setId(id);
   member.setName(name);
   member.setAge(age);
}
</code></pre>
</div>
<blockquote>
  <p>꽤 괜찮다고 생각할 수 있다. 하지만 클라이언트로부터 받아오는 데이터가 3개보다 훨씬많을 경우에는 코드가 굉장히 길어진다.
ModelAttribute 어노테이션은 이러한 문제를 본인이 짊어진다.
클래스앞에 @ModelAttribute를 붙이면 선언된 클래스를 하나 생성하여 내부에있는 모든 변수들에게 RequestParam을 한것과 같은 결과를 내어준다.</p>
</blockquote>

<blockquote>
  <p>클라이언트의 요청에 대한 응답이 api형태가 아니고 반드시 새로운 페이지를 redirect하는 서버의 경우, <br />
사실 위의 방법만으로도 거의 해결이 가능했던것 같다. 하지만 페이지 전환없이 ajax와같은 Data만을 요구하는 요청에 대해서는 
보통 Content Type이 Default이기 보다는 <code class="highlighter-rouge">application/json</code>으로 보내게 된다. 
앞에서 말한 것처럼 ModelAttribute와 RequestParam의 경우 <code class="highlighter-rouge">application/x-www-form-urlencoded</code>Type의 데이터만 다룰 수 있기 때문에 <br />
Json 형태로 넘어온 데이터에 대해서는 아무것도 할 수 없다.  그럴 경우 RequestBody를 사용하게 되는데 <br />
여기서 사람들이 잘못 이해하고 있는 부분이 있는 것 같다. <em>RequestBody는 Json을 위한 Parsing Annotation이 아니다.</em> <br />
RequestBody는 뒤에 명시한 Object와 클라이언트로 부터받은 Request의 Body 부분을 완벽하게 1:1 로 매칭시킨다. <br />
RequestBody를 사용한 경우 Spring은 Request로 부터 넘어온 Data를 명시한 Object에 완벽히 Parsing시켜줄 수 있는 Converter를 찾는다.
이러한 Converter들은 HttpMessageConverter 인터페이스를 구현한 구현체들이다.  <code class="highlighter-rouge">application/json</code> 형태로 넘어온 데이터의 경우 
Jackson을 기반으로하는 Converter가 이를 Parsing하여 Object에 그대로 mapping 해줄 수 있다.</p>
</blockquote>

<blockquote>
  <p>그렇다면 @pathvariable은 어떤 경우에 사용할까? <br />
@pathvariable의 사용은 REST API가 등장하면서 자주 사용하게 된 것같다. 사실 REST API를 준수하지 않는다면 RequestParam과 하는 역할이 동일하다.
차이점은 RequestParam의 경우 자신이 Mapping할 데이터를 ?뒤에서 즉, 쿼리스트링 또는 Request의 Body부분에 찾는다.
하지만  @pathvariable의 경우 Request하는 URI안에서 데이터를 찾는다. <br />
그렇기 때문에 @pathvariable은 <code class="highlighter-rouge">@GetMapping("/{productId}")</code>처럼 @XXXMapping 어노테이션과 함께 동작해야한다.
요청을 하는 URI로 부터 특정부분을 Mapping하고자 하는 것이 목적이기 때문에 URI에서 Mapping하고자 하는 부분을 명시를 해주고
파라미터를 통해서 그 부분을 Object에 Parsing할 수 있다.</p>
</blockquote>

<blockquote>
  <p>막상 정리를 하려고하니까 컨트롤러 메소드 파라미터관련해서는 정말 끝이 없는 것 같다. 일단은 이정도만..
<del>쓰다가 느낀거지만 Parsing이랑 Mapping 차이는 뭐지??;;;</del></p>
</blockquote>


	  ]]></description>
	</item>


</channel>
</rss>
