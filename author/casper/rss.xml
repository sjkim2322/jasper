<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>sjkim2322.github.io/logbook/</title>
   
   <link>http://sjkim2322.github.io/logbook/</link>
   <description></description>
   <language>en-uk</language>
   <managingEditor> SeongJin Kim</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>String</title>
	  <link>/logbook//java-String</link>
	  <author>SeongJin Kim</author>
	  <pubDate>2017-09-11T01:00:00+09:00</pubDate>
	  <guid>/logbook//java-String</guid>
	  <description><![CDATA[
	     <p><a href="http://www.thejavageek.com/2013/06/19/the-string-constant-pool/">링크</a></p>

<p>java의 Data Type은 크게 Primitive Type과 Reference Type으로 나뉜다. <br />
int, char, boolean 등과 같이 자바의 최상위 객체인 Obejct를 상속하지 않은 “비객체” 타입의 데이터타입을 “Primitive Type”이라 한다. <br />
그만큼 자주 사용되기도 한다.</p>

<p>String Type의 경우에는 사용하는 정도가 마치 Primitive Type처럼 사용된다. <br />
하지만 String은 Object에 기반한 Reference Type이다. <br />
String 클래스에 대해 자세히 알아보자.</p>

<h4 id="string-literal">String Literal</h4>
<p>java에서 String이 Reference 인지 Primitive인지 모호해지는 이유는  <br />
String Literal 때문이라고 생각한다.<del>아닐수도있고</del></p>

<div class="highlighter-rouge"><pre class="highlight"><code>String a = "literal";
String b = new String("literal");
</code></pre>
</div>

<p>Reference Type의 경우 기본적으로 새로운 객체를 생성하기 위해서는  <br />
new 키워드를 통해 해당 클래스의 Constructor를 실행시킴으로써 실행된다.</p>

<p>String의 경우 new Keyword를 통해서만 아니라 단순히 literal선언을 통해 String 객체를 생성하고 초기화할 수 있다. <br />
그렇다면 다음 코드의 결과를 예상해보자.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>a == b; //true or false?
a.equals(b); //true or false?
</code></pre>
</div>

<p>답은 <code class="highlighter-rouge">false, true</code> 이다. <br />
객체 수준에서의 == 연산자의 경우 2개의 instance가 같은 instance인지를 판단한다. <br />
첫번째의 답이 false인 것은 명백히 다른 instance이다. <br />
두번째의 답이 true인 것은 String 클래스 내부에서 Object클래스의 equals 함수를 어떻게 구현했는지를 보면 알 수있다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }
</code></pre>
</div>

<p>위 코드를 보면 String내부의 문자하나하를 비교하고 있는 것을 알 수있다. <br />
String 클래스에서는 equal의 의미는 같은 Instance이냐? 라는 의미보다 같은 문자열이냐? 라는 의미가 더 적절하므로 <br />
다른 Instance일지라도 문자열이 같으면 true를 Return 한다.</p>

<p>그렇다면 첫번째 답이 false인 이유를 알아보자.  코드를 더 추가해보자.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>String a = "literal";
String b = new String("literal");
String c = "literal";
String d = new String("literal");

a == c //??
b == d //??

</code></pre>
</div>
<p>위 코드의 답은 <code class="highlighter-rouge">true, false</code>이다. <br />
두번째 답의 경우 new 연산자가 각각 실행되었으므로 b와 d가 다른Instance인 것은 명백하다. <br />
하지만 a와c의 경우 비록 두번 선언되었지만 같은 객체인 것이라는 것을 알려준다. <br />
c가 초기화 될때 어떻게 a가 가리키는 객체를 가져올 수 있을까? <br />
String Literal의 동작방식을 더 깊게 이해해볼 필요가 있다.</p>

<h4 id="string-constantliteral-pool">String constant(literal) pool</h4>
<p>String constanst pool이란 Heap영역에 있는 String literal을 저장하는 pool이다. <br />
<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.5">java specification</a> <br />
String literal 또한 new를 통해 생성된 String 객체 처럼 String type의 객체이다. <br />
하지만 Compile Time에 String literal로 선언된 String은 Constant화 된다. <br />
즉, 최초 생성 이후 같은 문자열이 또다시 literal로 선언되는 경우 처음에 만들어 두었던 객체를 가리키도록 한다. <br />
상수화된 String객체는 일반 String 객체와 다른곳에 보관이 되어야한다. 상수화된 String 객체를 보관하는 곳이 <br />
String constant pool이다. <br />
literal로 선언된 String객체의 경우 또한 new로 생성한 String객체와 마찬가지로 String 객체가 하나 생성된다. <br />
하지만 이를 constant화 시키기위해 즉, String constant pool에 고립시키기위한 작업을 추가적으로 진행한다. <br />
Oracle의 명세에 의하면 다음과 같이 적혀있다.</p>

<p>“string literals are “interend” so as to share unique instances”</p>

<p>결국 literal로 선언된 String은 String객체를 생성한 이후 String 클래스의 native 함수인 <br />
intern함수를 통해서</p>
<div class="highlighter-rouge"><pre class="highlight"><code>String constant pool에 해당 문자열이 있는지 확인한 이후 있으면 그에해당하는 주소값을 
없으면 pool에 해당 문자열을 저장하고 그 주소값을 리턴
</code></pre>
</div>
<p>하는 작업을 진행한다.</p>

<p>위의 Specification에 적힌 6가지 points는 다음과 같다.</p>
<ul>
  <li>Literal strings within the same class in the same package  represent references to the same String object.
    <ul>
      <li>같은 package 내부의 같은 class안에서는 같은 문자열의 literal의 경우 같은 객체를 참조한다.</li>
    </ul>
  </li>
  <li>Literal strings within different classes in the same package represent references to the same String object.
    <ul>
      <li>같은 package 내부의 다른 class안에서는 같은 문자열의 literal의 경우 같은 객체를 참조한다.</li>
    </ul>
  </li>
  <li>Literal strings within different classes in different packages likewise represent references to the same String object.
    <ul>
      <li>다른 package이고 다른 class안에서는 같은 문자열의 literal의 경우 같은 객체를 참조한다.</li>
    </ul>
  </li>
  <li>즉, project 단위(??)로 constant pool이 생성되는 듯 하다.</li>
  <li>Strings computed by constant expressions are computed at compile time and then treated as if they were literals.
    <ul>
      <li>상수 표현식(literal)로만 연산된 String객체는 compiletime에 계산되어 마치 하나의 literal처럼 다뤄진다.</li>
    </ul>
  </li>
  <li>Strings computed by concatenation at run time are newly created and therefore distinct.
    <ul>
      <li>runtime시에 +연산된 String 객체(String 변수를 연산에 사용하는 경우)의 경우 새로운 객체를 생성한다.</li>
    </ul>
  </li>
  <li>The result of explicitly interning a computed string is the same string as any pre-existing literal string with the same contents.
    <ul>
      <li>String 객체의 intern 함수를 사용할 경우 객체의 value값과 정확히 일치하는 문자열을 constant pool에서 찾고 있으면 그것의 주소값을, 없으면 새로만든뒤 그 주소값을 리턴한다.</li>
      <li>즉, 새로 생성된(distinct한) String 객체를 constant화 시킨다.</li>
    </ul>
  </li>
</ul>

<h4 id="string의-immutable">String의 Immutable</h4>
<div class="highlighter-rouge"><pre class="highlight"><code>String a = "bb";
a += "c";

//a = "bbc"
</code></pre>
</div>

<p><a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.18.1">String Concatenation Operator +</a>  <br />
위의 Specification에 의하면 + 연산자를 포함한 연산식에서 하나의 피연산자가 String type인 경우, String이 아닌 다른 피연산자는 <br />
String Type으로 conversion되어  concatenation된다.</p>

<p>그리고,</p>
<div class="highlighter-rouge"><pre class="highlight"><code>The String object is newly created unless the expression is a constant expression.
</code></pre>
</div>
<p>피연산자에 해당하는 것들이 모두 literal방식이 아닐 경우 값의 할당이 runtime으로 넘어가게된다.
<code class="highlighter-rouge">a = "bb" + "cc";</code>의 경우 compile time에 “bb”와 “cc”가 합쳐진 “bbcc”를 constant pool에 저장한다.
(물론 “bbcc”라는 문자열이 기존에 만들어지지 않은 것이라면 여기서 최초의 객체 생성이 일어난다.) <br />
하지만 <code class="highlighter-rouge">a = "bb" + c</code> 처럼 String type의 변수 c를 연산에 포함시키는 경우 runtime에 새로운 String 객체가 생성되어 기존의 객체를 <br />
대신하여 a가 새로생성된 객체를 가리키도록한다.</p>

<p>이렇듯 초기화한 String 변수를 지속적으로 수정하는 작업은 새로운 String 객체를 계속해서 생성하기 때문에 성능상의 이슈가 있다.</p>

<p>Java에서는 이 문제를 해결하기 위해 StringBuffer와 StringBuilder를 제공한다.</p>

<h4 id="stringbuilder-stringbuffer">StringBuilder, StringBuffer</h4>
<p>String 클래스는 그 Value값이 Immutable하기 때문에 값을 수정할 경우 새로운 객체가 생성된다. <br />
StringBuilder는 이 문제를 해결할 수 있는 Mutable클래스이다. <br />
String과 기본 동작은 똑같지만 문자열이 수정될 경우, Value값 자체를 수정하기 떄문에 새로운 객체가 생성되지 않는다. <br />
하지만 Mutable한 특성은 Thread사용에 있어서 안전하지 못하다. <br />
String 클래스가 Immutable인 것도 Thread사용에 있어서 안전하게 하기 위함인 것으로 생각한다. <br />
StringBuilder를 통해서 Single Thread환경에서 새로운 객체생성에 따른 메모리 성능 이슈를 해결할 수있지만 <br />
Thread환경에서의 안전성을 잃어버렸다. <br />
이를 해결하기 위한 것이 StringBuffer이다. <br />
StringBuffer는 StringBuilder와 똑같은 구조를 가지고 있다. <br />
하지만 여기서 클래스 내부의 함수들에 synchronized 키워드를 이용하여 동시에 한개의 Thread에서만 사용할 수 있도록 제한함으로써 <br />
다중 Thread환경에서 발생하는 문제를 해결할 수 있다.</p>

<h4 id="string의-사용">String의 사용</h4>
<p>앞서 얘기한 것처럼 String은 Immutable하기 때문에 잦은 수정작업은 즉시 버려지는 새로운객체를 계속해서 생성한다. <br />
이를 해결하기 위해 StringBuilder나 StringBuffer를 사용하지만 Java명세에 의하면 다음과 같이 적혀있다.</p>

<ul>
  <li>An implementation may choose to perform conversion and concatenation in one step to avoid creating and then discarding an intermediate String object.
To increase the performance of repeated string concatenation,
a Java compiler may use the StringBuffer class or a similar technique to reduce the number of intermediate String objects that are created by evaluation of an expression.</li>
</ul>

<p>인터넷의 다른 블로그들을 찾아보면 JDK 1.5 버전부터 String은 CompileTime에 StringBuffer로 바뀐다는 글이 있다. <br />
하지만 명세에는 StringBuilder로 바뀐다는 직접적인 언급은 없고 지속적으로 새로운 객체를 생성하는 이슈를 해결하기 위해 이를 해결하는 Class를 사용할 수도 있다고 언급되어있다.</p>


	  ]]></description>
	</item>

	<item>
	  <title>HashMap</title>
	  <link>/logbook//java-hashMap</link>
	  <author>SeongJin Kim</author>
	  <pubDate>2017-09-07T01:00:00+09:00</pubDate>
	  <guid>/logbook//java-hashMap</guid>
	  <description><![CDATA[
	     <p><a href="http://d2.naver.com/helloworld/831311">참고링크  네이버 D2</a></p>

<p>사실 본인은 Map을 잘 사용해보지 않았다. <br />
map에 대한 깊은 이해가 없기도 하였고 대규모의 데이터 배열을 순회하는 등의 기능을 짜야할 프로젝트를 진행해본적도 
없었기 때문에 배열이나 리스트로 모든 것을 해결하려했다. <br />
하지만 부스트캠프를 진행하면서 배열이나 리스트를 순회하는 작업이 혼자서는 미처생각하지 못했던 대규모의 서비스에서만 발생할 수 있는 여러 이슈들이 있다는 것을 알게 되었다.</p>

<p>컴퓨터의 연산속도가 사람이 인식하는 정도의 속도로 느려질 수 있다는 것을 알게 되었다.</p>

<p>Map을 사용해보고자 했지만 내가 생각하는 방식으로 이해가 되지 않는 부분이 하낭 있었다.
java의 hashMap을 사용한다면 다음과 같은 형태로 사용을 하게 된다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>...
HashMap&lt;String , Person&gt; map = new HashMap&lt;String , Object&gt;();
		map.put("Kim", personKim);
		map.put("Lee", personLee);
		map.put("Park", personPark);
		map.put("Jang", personJang);
</code></pre>
</div>
<p>다음과 같이 작성하고 <code class="highlighter-rouge">map.get("Kim")</code>을통해 key값에 해당하는 value를 찾아오는게 Java의 Hashmap의 기본적인 형태이다.</p>

<p>내가 이해되지 않는 부분은 바로여기서 생겼다. <br />
hash를 사용한다는 것은 key값에 해당하는 “Kim”이라는 객체가 HashFunction에 의해서 어떤 값으로 바뀌게 되고 <br />
그 값으로 실제 value에 해당하는 객체를 바로 찾을 수 있을 것이다. <br />
물론 hash의 충돌이 발생할테지만 자바의 공식적인 API가 어떤식으로든 충돌을 최소화 했을 것이라 생각했다.</p>

<p>하지만 “Kim”이라는 키값이 hashfunction을 통해 변환된 값이 100이라고 하자. <br />
그렇다면 100이라는 값을 통해 hashmap은 personKim을 찾을 수있다. <br />
그 이후 “Lee”에해당하는 map이추가되는데 “Lee”의 hash변환값이 540이 되었다고 하자.
그렇다면 map또한 자료구조이므로 배열을 이용하여 기존에 100,personKim이라는 데이터 이후에 다음데이터가 쌓이게 될것이다.
첫번째 데이터 다음에 바로 540,personLee가 추가된다면 이런형태로는 일반 배열과 다를게 없다라는게  <br />
내 생각이었다.
<code class="highlighter-rouge">map.get("Lee")</code>를통해서 personLee를 찾으려고 할경우 “Lee”는 Hashfunction을 거쳐 <br />
540이라는 값을 갖게 될 것이고 이 540에 해당하는 데이터가 있는지 없는지, 있으면 어디에 있는지 <strong>배열순회</strong>를 통해 찾아야한다. <br />
하지만 HashMap이라는 클래스가 내부적으로 배열을 순회하는 형태라면 굳이 사용할 필요가 없을 것이다. <br />
내가 생각하기로는 배열을 순회하는 형태가 되지 않으려면 hashfunction을 통한 값자체가<br />
배열의 index가 되어야한다고 생각했다. 그렇게 되면 한번에 찾을 수 있게 되니까. <br />
그런데 이 것은 더 말이 안된다. <br />
만약 2번째 “Lee”의 hash 값이 “3000000”이고 이값이 배열의 index가 되려면
첫번째 “kim”과 Lee사이에 무려 2999900개의 빈 배열이 있어야할 것이다. <br />
HashMap이 내부적으로 이렇게 구현됐을리는 없을 것이다. <br />
그렇다면 Hashfunction자체가 배열의 크기를 조절한다는 얘기가 된다는 것인데 <br />
이럴 경우 충돌이 발생할 확률이 매우 높아질 것이라고 생각했다.</p>

<p>자료를 찾아보니 ~<del>자료라고해봐야 위의 링크를 읽은게 다이지만.. 그만큼 잘설명되있다.</del> <br />
후자의 형태로 구현이 되어있다는 것을 알게 되었다. <br />
사실 첫번째 생각은 아무리 생각해도 말이 안된다.</p>

<p>HashMap은 적은양의 메모리만을 사용하며 여기서 발생하는 추가적인 충돌을 효과적으로 해결하는 방법을 발전됐다.</p>

<h3 id="hashcode">HashCode</h3>
<p>hashcode함수는 자바의 Object가 가지고있는 함수로써 C언어의 &amp;와 똑같은 것이라 생각했다. <br />
참 어리석었다. 함수이름에 Hash라는 말이 적혀있는데 hashcode의 결과값이 실제 메모리 주소라고 생각했으니 말이다.</p>

<p>다시 본론으로 들어가면 HashMap은 기본적으로 Key에 대한 Hash값을 Key 객체의 Hashcode값으로 사용한다. <br />
hashcode함수의 return type은 int형인데 그렇다라는 얘기는 이 hashcode의 결과값을 그대로 Hashmap의 hash로 사용하면 <br />
O(1)을 위해 2의32승 만큼의 배열이 만들어져야한다. <code class="highlighter-rouge">newHashMap&lt;&gt;()</code>한번에 2의 32승길이의 배열이라니  <br />
말도 안된다.</p>

<p>HashMap은 어느정도로 충돌을 감안하고 Hashcode의 범위를 다음과 같은 형태로 줄인다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>X.hashCode() % M;
</code></pre>
</div>
<p>hashCode의 리턴값을 정수의 표현범위보다 낮은 M으로 나눈 나머지를 HashMap의 Index로 사용한다. <br />
이렇게 되면 배열의 크기는 M이 되고 1/M확률로 Hashfunction과는 다른 의미의 또다른 충돌이 생겨난다.</p>

<p>HashMap은 이러한 또다른 의미의 충돌을 효과적으로 해결하는 방법을 찾아 지속적으로 발전됐다.
그렇다면 충돌을 해결하는 방법을 자세히 알아보자.</p>

<h3 id="open-addressing">Open Addressing</h3>
<p>위에서 얘기한 예제를 통해서 알아보자. <br />
맨 처음 hashMap을 생성하고 <code class="highlighter-rouge">map.put("Kim", personKim);</code>을 실행하면 <br />
“Kim”이라는 객체의 hashcode를 M으로 나눈다. 만약 이값이 3이 나올경우 배열의 3Index에 personKim의 reference가 들어간다. <br />
이 후 <code class="highlighter-rouge">map.put("Lee", personLee);</code>를 실행하면 같은 작업이 반복되는데,<br />
만약 여기서 “Lee”객체의 hashCode를 M으로 나눈 값 또한 3이 나왔다고 치자. <br />
바로 이런 경우가 배열의 크기를 M으로 줄이면서 발생한 또다른 의미의 충돌인 것이다. <br />
Open Addressing 방식의 경우 단어의 의미 그대로 address를 열어 둔다는 뜻으로 <br />
3 Index에 이미 다른 Value값이 있다면 3부터 M-1까지의 Index까지 순차적으로 비어있는 Index를 찾는다.  <br />
인터넷에 보면 최악의 경우 배열을 순회한다고 나와있지만 Key를 통해 Value를 찾을 때는 맞는 얘기이지만 최초 삽입 시에는 Java의HashMap은 배열이 어느정도 차게 되면 동적으로 M값을 늘려 <br />
추가적인 공간을 형성하므로 순회하는 경우는 생기지 않는다. 하지만 빈 Index를 만날때까지 배열을 탐색하는 것은 변함없다. <br />
OpenAddressing 방식은 연속된 공간에 데이터를 저장하기 때문에 캐시 효율이 높다고 한다. <br />
하지만 큰 단점이 있다. 바로 삭제 연산인데, 어떤 데이터를 삭제해버리면 그부분의 Index를 거치는 검색연산이 다음 Index를 탐색하지 않고 비어있는 Index에서 <br />
멈춰버리기 때문에 Dummy node를 이용해서 순회가 지속되도록 하는 작업이 추가로 발생한다. <br />
그렇기 때문에 자바에서는 Open Addressing을 사용하지 않고 다음에 얘기할 Seperate Chaining 방식을 사용한다.</p>

<h3 id="seperate-chaining">Seperate Chaining</h3>
<p>Open Addressing과 가장 큰차이는 HashMap의 사용되는 배열이 담는 데이터 타입이다. <br />
Seperate Chaining의 경우 각 Index에 해당하는 공간은 데이터를 담을 수 있는 LinkedList의 head값이 담을 수 있다. <br />
즉, 충돌이 발생한 경우 원래 배열에 빈공간을 찾지 않고 Index에 연결된 LinkedList를 타고들어가 마지막에 데이터를 저장한다. <br />
Seperate Chaining의 경우 HashMap과 관련한 연산이 충돌이 발생하더라도 최악의 경우 충돌이 발생한 Data들만 순회를 하면 되므로 
Open Addressing방식보다 좋다고 할 수 있다.</p>

<h3 id="in-java8">In Java8</h3>
<p>하지만 Seperate Chaining의 경우에도 충돌하는 데이터가 많아졌을 경우 전체 Linked List를 순회해야하는 문제는 여전히 존재한다. <br />
Java8에서는 충돌이 많아지는 경우 Linked List 형태의 구조를 트리형태로 바꿈으로써 검색하는 속도를 더 줄일 수 있다.  <br />
Linked List의 크기가 8개가 되면 HashMap은 LinkedList를 트리로 전환한다. <br />
그리고 삭제 연산을 통해서 트리의 개수가 6개가 되면 다시 LinkedList로 변환한다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Prototype</title>
	  <link>/logbook//javascript-prototype</link>
	  <author>SeongJin Kim</author>
	  <pubDate>2017-09-07T01:00:00+09:00</pubDate>
	  <guid>/logbook//javascript-prototype</guid>
	  <description><![CDATA[
	     <h3 id="javascript의-class">JavaScript의 Class</h3>
<p>기본적으로 자바스크립트에서는 Class라는 개념이 없다. <br />
ES6 스펙에 공식적으로 Class를 사용할 수 있는 문법이 추가 되었다. <br />
하지만 여기서 사용하는 Class의 문법이 java와 같은 언어에서 동작하는 Class와 엄연히 다르다는 것을 알아야한다.</p>

<h3 id="new">new</h3>
<p>java에서는 new 키워드를 통해서 클래스의 인스턴스를 생성한다.</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//java   
Person person = new Person();
</code></pre>
</div>
<p>javascript에서도 new라는 키워드는 존재하며 사용하는 방식 또한 비슷하다.</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//javascript   
var person = new Person();
</code></pre>
</div>
<p>여기서 다른 점은 Type과 Person이 클래스이냐 함수이냐의 차이이다. <br />
javascript에서 함수가 하는 역할은 java와 다르다. <br />
일반적으로 java와 같은 언어에서 함수의 역할은 “일련의 처리를 하는 로직이 담긴 Block” 정도가 되겠다. <br />
하지만 javascript에서는 위의 역할을 포함함과 동시에 <strong>“새로운 객체를 생성하는 생성자”</strong> 의 역할도 담당한다.<br />
다음 코드를 보자.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function test() {
    this.name = "Kim";
}
</code></pre>
</div>
<p>다음과 같은 코드를 new 키워드를 이용하여 생성자 함수로써 사용할 수 있는데 실행하면 다음의 작업들이 순차적으로 실행된다.</p>

<ol>
  <li>빈 오브젝트 생성</li>
  <li>실행된 함수의 this value를 1번에서 생성한 빈 오브젝트에 바인딩</li>
  <li>생성자함수의 prototype Object를 1번에서 생성한 빈오브젝트의 prototype으로 설정</li>
  <li>생성자 함수의 내부 실행</li>
  <li>특별히 명시된 return 문이 없는 경우 1번에서 생성한 오브젝트를 Return</li>
</ol>

<h3 id="prototype">Prototype</h3>
<p>그런데 new 키워드를 통해 함수를 생성자로써 사용하는 것과 Prototype이랑 무슨 관계가 있는 것일까? <br />
java와 같은 언어에 존재하는 상속과 같은 개념을 javascript에서는 prototype을 이용하여 흉내를 낼 수 있다. <br />
앞서 얘기 한 것처럼 javscript의 함수의 역할은 새로운 객체를 생성하는 생성자 역할을 포함한다. <br />
여기서 추가적으로 더 알아야할 것은 javascript의 객체는 반드시 자신의 부모역할을 하는 객체와 연결이 되어있다. <br />
이러한 객체를 <strong>ProtoType객체</strong> 라고 한다.</p>

<p>여기서 크롬 브라우저의 개발자 도구를 이용해서 객체의 내부를 살펴보면 의미의 혼돈이 생기게 된다. <br />
그럴 수 밖에 없는 이유는 생성자역할을 하는 함수의 경우 함수의 자체적인 프로퍼티로 다음과 같은 2개의 프로퍼티를 갖는다.</p>

<ol>
  <li>prototype</li>
  <li>__proto__</li>
</ol>

<p>앞서 얘기한 ProtoType객체에 해당하는 부분은 __proto__에 해당한다. <br />
prototype 프로퍼티는 일반 객체는 갖고 있지 않은 프로퍼티로, 생성자 자격이 있는 함수가 새로운 객체를 생성할 때  <br />
그객체의 Prototype 객체에 연결 시켜주기 위한 object를 가리키고 있는 프로퍼티이다.</p>

<p>javscript의 모든객체는 prototype을 가지고 있고 어떤객체의 prototype또한 prototype을 가지고 있다. <br />
즉, prototype은 chaining 되며 최종 객체인 Object까지 올라 갈 수있다.  <br />
이 chaining을 통해서 객체 내부에 존재하지 않는 변수나 함수 일지라도 prototype에 있는 경우 이를 사용할 수 있게 된다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>MessageConverter</title>
	  <link>/logbook//Spring-MessageConverter</link>
	  <author>SeongJin Kim</author>
	  <pubDate>2017-09-06T00:00:00+09:00</pubDate>
	  <guid>/logbook//Spring-MessageConverter</guid>
	  <description><![CDATA[
	     <h4 id="의문점">의문점</h4>
<p>Spring을 이용해서 Web Application개발을 하다보면 자연스럽게 REST API를 접하게 되고 <br />
 굳이 REST API를 사용하지 않더라도 클라이언트 단에서 XmlHttpRequest를 기반으로하는 Jquery의 Ajax 등을 이용해<br />
 화면전환없이 Data만을 요청하는 경우가 생긴다.</p>

<p>이러한 경우가 없다면 Spring에서 ViewResolver를 이용해서 컨트롤러의 return 값을 viewResolver를 거쳐 <br />
 원하는 페이지를 Response하는 형태가 일반적이다.</p>

<p>페이지 형태(html)의 Response가 아닌 Data만을 Response하고자 하는 경우 구현하는 방법은 생각보다 너무 쉽다.
 컨트롤러의 함수 위에 <code class="highlighter-rouge">@ResponseBody</code> 라는 어노테이션만 명시해주면 함수의 Return 자체가 Response의 Body로 들어가게 된다.
 즉, ViewResolver를 거쳐 서버의 Resource내부의 html파일(jsp 인경우도 있고)을 찾는 과정이 생략된다.
 코드로 살펴보자.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    @GetMapping("/{categoryId}/products")
    @ResponseBody
    public List&lt;Product&gt; getProductsByCategoryId(@PathVariable Integer categoryId) {
        return productService.getByCategoryId(categoryId); // return List&lt;Product&gt;
    } 
</code></pre>
</div>
<p>위의 코드의 어노테이션에 ResponseBody 이 쓰여있으므로 이 함수의 return은 그대로 요청에대한 응답인 Response의 Body에 들어가게 된다.</p>

<p>여기서 본인은 의문점이 생겼다. <br />
java의 클래스형태은 Bean을 Response의 body에 담았는데 java의 형태 그대로 클라이언트에 전달될 리는 없을 테고  클라이언트로 결과를 전송하기 전에 <br />
무엇인가를 거쳐가는 듯한데 그것이 과연 무엇인가? 라는 의문이였다.</p>

<h4 id="예상">예상</h4>
<p>자바를 공부하면서 직렬화에 대해서 미약하게 나마 공부하였고 자바의 데이터가 자바의 외부로 빠져나갈 때는 반드시 <br />
직렬화되어 나간다고 들었던 기억이 났다. <br />
스프링에서도 마찬가지라고 생각했고 내 생각이 맞는지 인터넷을 뒤져보았다. <br />
찾은 내용은 다음과 같다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>It does not. When you return an instance from controller method annotated with @ResponseBody   
you might say that it is serialized to JSON for instance. But this kind of serialization is not the Java serialization which involves Serializable interface.   
@RequestBody and @ResponseBody annotations are handled by RequestResponseBodyMethodProcessor which uses HttpMessageConverter implementations to perform the conversion for example from object to JSON or from JSON to object.
When you look at the HttpMessageConverter interface there is a canRead method which has the following signature: boolean canRead(Class&lt;?&gt; clazz, MediaType mediaType); and as you can see it is not bound to only serializable classes using generics.
</code></pre>
</div>

<h4 id="결론">결론</h4>
<p>지난 포스팅에서도 잠시 언급한 RequestBody 어노테이션에서 얘기한 것처럼 Spring은 MessageConverter를 이용하여
클라이언트와 서버간 데이터를 주고받을 때 데이터의 format을 맞춰주는 것 같다.
messageConverter 인터페이스를 구현한 여러 구현체들이 서버가 실행될 때 로드가 되고, 컨트롤러의 함수들중 요청한 URI와 일치하는 <br />
함수에게 Request의 Body에 있는 내용들을 요청과 함께 넘어온 Content-type과 함께 Converting할 수 있는 converter구현체를 찾는다.
함수의 로직이 실행되고 ResponseBody를 통해서 Bean을 클라언트로 넘겨 줄 때도 클라이언트가 응답을 받고자하는 포맷을 확인하고 
Bean을 이형태로 Convert해줄 수 있는 구현체를 찾아 Converting을 한다.</p>

<p>사실, ajax 를 이용해서 json형태로 응답을 받고자할 때 자신이 응답으로 받고자 하는 format을 딱히 설정하지 않아도 잘 받을 수 있는 경우가 있는데 <br />
<a href="http://api.jquery.com/jquery.ajax/">jquery의 ajax에 관련한 document</a>를 참고하면 “Intelligent Guess”라고 설명되어 있다.
즉, 별도로 명시하지 않아도 어느정도는 format을 자체적으로 결정할 수 있다.</p>

<p>하지만 클라이언트와 서버간 데이터통신의 format에 대해 자세히 이해하고 원하는 정보들을 직접 입력하여 사용하는 것이 <br />
코드를 최적화는 시작 단계가 아닌가라고 생각한다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Spring Jdbc의 join과 Integer</title>
	  <link>/logbook//Spring-Join-Integer-Wiki</link>
	  <author>SeongJin Kim</author>
	  <pubDate>2017-09-05T08:00:00+09:00</pubDate>
	  <guid>/logbook//Spring-Join-Integer-Wiki</guid>
	  <description><![CDATA[
	     <p>Join과 Integer라니 글의 주제가 꽤나 Matching되지 않아 보인다.
하지만 본인이 개발하면서 저 2가지의 개념사이에 연결부분이 존재했고 그것에 대해 이야기하고자 한다.</p>

<p>Integer란 java의 int Type에 대한 WrapperClass로써 Primitive Type인 int형 변수를 Reference Type 즉, 클래스처럼 다루고자 할 때 사용한다. <br />
데이터베이스를 연동하는 웹 프로젝트의 경우 Integer Class가 자주 사용되는데 그 이유는 <strong>Null 값을 담을 수 있다.</strong> 라는 점에 있다.</p>

<p>JDBC를 이용하여 데이터베이스의 Datatype이 int 형인 데이터를 가져오는 쿼리문의 수행결과를 Java단으로 가져오는 경우를 생각해보자.
데이터베이스에서는 기본적으로 조건을 걸지 않는다면 모든 컬럼이 Null일 수 있다. <br />
그렇다면 Null인 int형 컬럼을 JDBC를 통해 가져와서 java의 int형 변수에 할당하려고 한다면 어떻게 될까? <br />
당연한 결과겠지만 Error가 나게 된다.</p>

<p>사실, 데이터베이스의 쿼리결과를 Mapping하는 Object의 경우 int형 변수들이 필요하다면 모두 Integer로 변환하면 <br />
간단하게 해결될 문제이지만 primitive type인 int변수를 쓸 수 있는 상황에서도 Wrapper클래스를 사용한다면 리소스를 낭비하는 꼴이 된다. <br />
그렇기 때문에 Null값이 할당될 여지가 없는 경우에는 primitive type을 사용하는 것이 바람직하다. <br />
예를 들면 데이터베이스의 테이블에서 Primary key로 사용되는 컬럼의 경우 기본키는 무조건 Not null 속성을 가지고 있기 때문에 <br />
이를 java단에서 Mapping하는 변수의 경우에도 primitive type을 사용하여도 문제가 없을 것이다. <br />
(물론 Application 내부의 로직 단위에서 이 변수에 Null이 할당되는 경우 같은 에러가 나겠지만 이는 별게의 문제로 보는 것이 맞는것 같다.)</p>

<p>하지만 primary key로써 Not null을 보장받는 컬럼이라 할지라도 java단에 mapping될 때 Null값이 들어오는 경우가 있다.
바로 제목에서도 언급한 Join과 관련된 부분이다.</p>

<p>일반적인 Inner Join의 경우만을 생각한다면 잘 이해가 안될 수도 있다. 애초에 값이 있는 컬럼들이 Join을 한다고 해서 값이 비워질 수는 없는 노릇이기 때문이다. <br />
하지만 Outer Join의 경우를 생각해보자</p>

<p>상품 정보 테이블과 상품 상세 정보 테이블이 있다고하자. <br />
두 테이블 간에는 관계가 형성 되는데 상품 정보는 상품상세 정보를 갖지 않을 수도 있고 1개 가질 수 있다.</p>

<p>이러한 상황에서 상품정보와 상품 상세 정보를 Join한 결과를 JDBC를 통해서 가져온 뒤 Object에 Mapping을 한다고 가정하자. <br />
상품 상세 정보를 갖지 않는 상품 또한 쿼리의 결과에 포함되어야 하기 때문에 Inner Join을 사용한다면 원하는 결과를 얻을 수 없다. <br />
이를 해결하기 위해서는 상품 상세정보가 없는 상품정보 레코드들도 결과로 갖게 되는 Outer Join을 사용해야한다.</p>

<p>여기까지는 별다른 문제가 없다. <br />
하지만 문제는 java의 Object에 Mapping하는 순간 발생하게 된다. <br />
Outer Join을 이용하여 쿼리를 실행한 결과중 다음과 같은 결과가 있다고 생각해보자.</p>
<table>
<tr>
<th>상품정보.상품 ID</th><th>상품정보.상품명</th><th>상품상세정보.상세정보ID</th><th>상품상세정보.제작사</th>
</tr>
<tr>
<td>1</td><td>양말</td><td>11</td><td>양말공장</td>
</tr>
<tr>
<td>2</td><td>신발</td><td>null</td><td>null</td>
</tr>
</table>

<p>첫번째 row의 경우에는 아무 문제가 없다. 하지만 두번째 row의 경우 신발에 해당하는 상품상세 정보가 없었기 때문에 <br />
그자리에 null값이 결과로 반환되게 된다. JDBC에 연결된 Mapper는 이러한 정보들을 java의 Object에 Mapping을 시도하게 되고 <br />
앞에서 얘기 했던 것처럼 우리는 primary key는 Null일 수 없으므로 int형 변수로 선언을 해두었다. <br />
이러한 상황이 생기게 된다면 JDBC는 Error가 발생하게 되고 우리는 원하는 결과를 얻을 수가 없다.</p>

<p>Application이 동작하면서 사용하는 리소스를 최소화시키기 위해 primitive type을 사용하는 것은 좋지만 <br />
이러한 작업들을 예외없이 처리하기 위해서는 많은 경험이 필요하다는 것을 새삼 느끼게 해주었던 사례였다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Javascript Hoisting 과 Execution Context</title>
	  <link>/logbook//Javascript-Hoisting</link>
	  <author>SeongJin Kim</author>
	  <pubDate>2017-09-03T07:30:00+09:00</pubDate>
	  <guid>/logbook//Javascript-Hoisting</guid>
	  <description><![CDATA[
	     <p><br />
 사실 본인은 자바스크립트가 꽤나 근본이 없는 언어라고 생각했다. <br />
<del>아무렇게 작성해도 알아먹으니까.</del> <br />
특히나 Hoisting가 관련된 부분은 꽤 골머리를 썩혔다. 잘동작했던 코드였는데 잘되다가 안되다가..
그 당시에는 괜히 자바스크립트를 탓했었다. <br />
하지만 그러한 이유는 본인에 무지함에 있었다는 것을 Hoisting을 이해한 뒤로 알게 되었다. <br />
이 글을 읽고 내글의 제목에 Execution Context를 추가했다. Hoisting만 얘기하기에는 설명이 부족할 것같다.
<a href="http://poiemaweb.com/js-execution-context">한글로 제일 잘 설명된 Execution Context 관련 글</a>이라 생각한다.</p>

<h4 id="hoisting의-오해">Hoisting의 오해</h4>

<h5 id="1">1.</h5>
<p>Hoist 라는 단어의 뜻(들어올리다)이 그렇듯, 특정 코드를 가장위로 들어올려주는 것으로 생각한다.
하지만 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting">Mozila</a>에 쓰여진 바로는 다음과 같다.</p>

<ul>
  <li>hoisting teaches that variable and function declarations are physically moved to the top of your coding, 
but this is not what happens at all. What does happen is that variable and function declarations are put into memory during the compile phase,
but stays exactly where you typed it in your coding.</li>
</ul>

<p>즉, Hoisting이라는 것은 우리가 작성한 코드의 물리적 위치를 변경하지 않는다. 단순히 선언식을 먼저 가지고 있는 것일 뿐</p>

<h5 id="2">2.</h5>
<p>Hoisting이라는 것이 자바스크립트가 사용하는 특별한 기능을 지칭하는 말이 아니다. <br />
자바스크립트가 코드를 읽는 방식을 이해한다면 지극히 당연한 기능이지만 코드를 작성하는 입장(Java나 C를 먼저 접한사람이라면)에서는 꽤나 어색하게 느껴진다.
그렇다면 도대체 Hoisting이 뭘까? 자세히 알아보자</p>

<h4 id="실행-컨텍스트">실행 컨텍스트</h4>
<p>사실 Hoisting 뿐만 아니라 클로저,Scope 더 나아가 ES6의 Generator 까지 실행 컨텍스트를 이해하면 모든 의문이 풀린다.
앞에서 얘기한 링크를 많이 참고하였다.       <br />
실행 컨텍스트(이하 EC)란 자바스크립트 코드를 실제로 <strong>실행 시키기 전</strong>에 실행에 필요한 정보를 담고 있는 객체이다.    <br />
최초 글로벌 EC를 필두로 함수가 호출될때마다 함수EC가 스택에 차례로 쌓이게 된다.       <br />
Active Context(현재 활성화된 컨텍스트)는 모든 시점에서 정확히 1개이다. =&gt; 엔진 콜스택의 최상단        <br />
<u>함수 종료시 해당함수의 EC는 파기되고 스택에서도 사라진다.</u>    <br />
그리고 해당함수를 호출한 컨텍스트가 Active Context가 된다. <br />
ES6에 추가된 Generator함수의 경우 위의 밑줄 친 문장은 예외가 된다.    <br />
Yield를 통해 함수의 컨텍스트를 빠져나가게 되는데 이 때 Generator함수의 EC는 파기 되지 않고 현재 상태를 기억하고 있다.      <br />
자세한 내용은 <a href="https://www.ecma-international.org/ecma-262/6.0/#sec-execution-contexts">ECMA 명세</a>를 다시한번 읽어봐야할 듯하다. <br />
<del>한번 읽어봤는데 잘모르겟다 영어를못해서..</del></p>

<blockquote>
  <p>앞서 얘기했듯이 EC는 객체이다. 객체이기 때문에 다음 3가지를 Property로 갖는다.</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>//ExecutionContext
{
    VariableObject : "",
    ScopeChain : "",
    thisValue :""
}
</code></pre>
</div>

<h5 id="1variable-object-이하-vo">1.Variable Object (이하 VO)</h5>

<blockquote>
  <p>실행에 필요한 실제 변수들을 담고 있는 객체를 가리키는 객체이다. <br />
최초에 생성되는 전역 EC의 경우 VO프로퍼티는 전역객체(Global Object 이하 GO)를 가리킨다.     <br />
GO는 전역으로 선언된 함수와 변수를 프로퍼티로 갖는 객체이다. <br />
GO의 경우 모든 Scope에서 접근이 가능하다(Global 객체이므로) <br />
그래서 Built-in object(Math, String, Array 등)와 BOM, DOM이 Set 되어있다.
그리고 전역 Scope에 있는 함수와 변수 선언을 포함하고 있다.</p>
</blockquote>

<blockquote>
  <p>전역코드 뿐만 아니라 함수가 자바스크립트의 CallStack에 들어올때(함수가 호출되어 실행될 때) 또한 EC가 하나생성되고 VO가 생성된다. <br />
함수의 경우, 전역 EC와 달리 VO는 전역객체를 가리키지 않고 Activation Object를 가리키게 된다.
Activation Object의 경우 앞에서 얘기한 GO와 거의 동일하지만 <br />
<u>Built-in object를 포함한 전역객체만의 프로퍼티들</u>을 포함하지 않고 <br />
대신 함수의 인자를 배열형태로 담고 있는 <u>Argument Object</u>가 추가된다.
Argument Object는 함수를 선언시 설정한 파라미터들과는 별개로 보는게 맞는 것같다.</p>
  <div class="highlighter-rouge"><pre class="highlight"><code>function foo(var1,var2,var3) {
    ...
}
foo(1,2,3,4); // thisLine
</code></pre>
  </div>
  <p>다음과 같은 코드의 경우 <code class="highlighter-rouge">thisLine</code> 에서 함수가 callStack에 들어가게 되고 EC가 생성되는데 <br />
함수가 선언될 때는 파라미터를 총 3개를 받지만 호출시에는 총 4개의 인자를 넘겨준다. <br />
이런 경우, 자바같은 경우는 컴파일 에러가 나는 것으로 알고 있지만 <br />
자바스크립트의 경우 그대로 실행되며 여기서 EC가 생성되고 AO에 Argument Object가 생성될때 <br />
그 배열의 길이는 총 4개가 된다. 물론 초기에 선언해둔 변수에 Mapping되는 것은 1,2,3뿐이지만 <br />
AO에는 생성이 되었기 때문에 arguments 오브젝트에 접근해서 값을 사용할 수 있다.
AO에 Argument Object가 생성된 이후로는 GO와 동일한 형태로 현재 Scope에 새롭게 추가된 변수,함수 선언을 AO에 담는다.</p>
</blockquote>

<h5 id="2scopechain">2.ScopeChain</h5>
<blockquote>
  <p>자바나 C를 먼저 공부했던 본인의 입장에서는 ScopeChain은 너무나도 당연한 것이 였지만 <br />
자바스크립트에서는 ScopeChain의 열할이 단순히 상위 스코프를 연결해주는것에서 그치지 않는다는 것이다.
기본적으로 ScopeChain 프로퍼티는 배열이고, 0 번째 Index에서는 현재 EC에서 최초로 생성된 AO를 가리킨다. <br />
1번째 Index는 현재 EC의 상위 컨텍스트에 있는 EC의 AO를 가리킨다. <br />
이런식으로 마지막에는 전역 EC의 GO까지 배열에 담기게 된다. <br />
이러한 ScopeChain 때문에 현재 Scope의 상위에 있는 모든 변수와 함수들에게서 접근을 할 수 있게 된다. <br />
즉, 변수와 함수의 호출이 실행될 경우 그 이름과 일치하는 프로퍼티를 ScopeChain의 0번째 index에서 부터 차례대로 <br />
GO까지 탐색을 하는 과정을 거친다. <br />
(개인적인 생각으로는 EC를 생성하는 시점에 컨텍스트를 타고 타고 올라가는 과정을 거치지는 않을것같다. <br />
현재 AO를 0번째 인덱스에 담고 그이후로는 상위컨텍스트의 ScopeChain을 그대로 덮어쓰지 않을까 싶다.)
또, 이 ScopeChain은 [[Scope]]라는 프로퍼티로 접근이 가능하다.</p>
</blockquote>

<h5 id="3thisvalue">3.thisValue</h5>
<blockquote>
  <p>우리가 코드를 작성하면서 this라는 변수를 사용할 수 있었던 이유는 바로 EC가 this라는 프로퍼티를 생성하기 때문이다. <br />
this의 값은 함수의 호출패턴에 의해 결정된다고한다.(???)</p>
</blockquote>

<p>그런데 왜 본인은 Hoisting을 이야기하다가 갑자기 실행 컨텍스트를 이야기하고 있는가? <br />
사실 앞에서도 얘기 한 것처럼 Hoisting이라는 것은 뭔가 특별한 기능을 뜻하지 않는다고 했다.
단순히 실행컨텍스트의 동작방식을 이해하게 된다면 Hoisting뿐만 아니라 클로저도 이해를 할 수 있다.
그렇다면 EC가 위에 언급한 3개의 프로퍼티를 가지고 어떤식으로 동작하는지 알아보자.</p>

<h4 id="실행컨텍스트의-생성과-동작-방식">실행컨텍스트의 생성과 동작 방식</h4>
<p>실행 컨텍스트는 script코드가 최초에 실행될 때 처음으로 한개 생성된다. <br />
브라우저의 경우 여기서 생성된 전역 컨텍스트는 함수가 종료되었을때 파기되는 다른 EC와달리 페이지가 전환되기 전까지 살아 있다.
앞서 얘기한 것처럼 전역 컨텍스트의 경우 VO에 매핑되는 Object가 다른함수들과 달리 Global Object가 매핑된다고 하였지만
우리가 작성한 코드가 Window이라는 모든 코드를 포함하고 있는 큰함수가 덮고 있다고 생각하면 일반적인 함수의 EC와 같다. <br />
즉, Global Object는 Window이라는 모든 코드를 포함하는 함수의 Activation Object이다.</p>

<p>실행컨텍스트가 동작하는 순서는 다음과 같다.</p>
<h5 id="1-비어있는-activation-object-생성">1. <strong>비어있는</strong> Activation Object 생성</h5>
<h5 id="2-scopechain-생성-및-초기화">2. ScopeChain 생성 및 초기화</h5>
<h5 id="3-variable-instantiation-실행">3. Variable Instantiation 실행</h5>
<h5 id="4-this-value-결정">4. This value 결정</h5>

<p>맨위에 언급한 글에서는 ScopeChain 생성이 가장 먼저로 언급되어 있지만 그전에 빈 AO의 생성이 이루어져야 한다.
빈 AO를 생성하는 것은 실행컨텍스트의 열할이 아니므로 언급이 안된 것 같지만 이해를 위해 첫번째에 생성이 된다고 작성하였다.</p>

<h5 id="1비어있는-activation-object-생성">1.<strong>비어있는</strong> Activation Object 생성</h5>
<blockquote>
  <p>여기서 중요한 것은 <strong>비어있는</strong> 이다. <br />
추후 AO에 모든 변수,함수 선언들이 담길예정이지만 초기에는 비어있는 상태로 생성이 되게 된다. <br />
하지만 Global인 경우 완전히 비어있는 것은 아니고 위에 얘기한 것처럼 Built in Object를 포함한 것들이 생성되어 들어있다. <br />
함수 EC의 Activation Object의 경우에도 완벽히 비어있지는 않다. 함수의 EC가 생성되는 시점은 그 함수가 호출된 시점이므로 <br />
여기서 arguments객체가 생성된다. 함수에 전달된 인수가 하나도없을지라도 arguments객체는 생성된다.(이객체의 property로 callee,symbol,length 등이 생성된다.) <br />
즉, “비어있다”라는 의미는 곧 실행될 Variable Instantiation이 실행되지 않았다는 정도로 이해하는 것이 좋을 듯하다.</p>
</blockquote>

<h5 id="2scopechain-생성-및-초기화">2.ScopeChain 생성 및 초기화</h5>
<blockquote>
  <p>ScopeChain의 생성이 이 시점에서 이루어지는 것은 꽤나 중요하게 생각해야할 부분이다.
함수가 호출되기 전에, 심지어는 3번의 Variable Instantiation이 수행되기 전에 <br />
ScopeChain이 생성되고 초기화가 일어난다는 것은 <br />
어떤 Scope(함수이거나 글로벌이거나)의 코드들이 실행되기 전에 그 Scope에 접근할 수 있는 범위가 결정된다는 얘기이다.
쉽게 코드로 예를 들어보자.
<strong><a href="https://www.zerocho.com/category/Javascript/post/5741d96d094da4986bc950a0">이 글</a>의 코드를 살짝 수정하였습니다.</strong></p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>var name = 'global';
function wow() { 
  console.log(name); // "global";
}
function say () {
  var name = 'inner';
  console.log(name); // "inner"
  wow();
}
say();
</code></pre>
</div>
<blockquote>
  <p>지극히 당연한 얘기일 수도 있겠지만 위 코드에서 wow함수 내부의 name 변수가 전역의 “global”인 것은 <br />
ScopeChain이 함수가 호출되는 시점이 아닌 생성하는 시점에 형성이 되었기 때문에 wow함수의 ScopeChain에는 <br />
say함수의 VO가 없다.(say함수안에서 단순히 wow함수를 호출만 하였으므로)</p>
</blockquote>

<blockquote>
  <p>다시 ScopeChain 얘기로 돌아와서 1번에서 생성한 AO를 ScopeChain의 0번째에 할당한다. <br />
그리고 현재 EC가 실행되기 전에 그전 컨텍스트에 생성 되있던 VO의 [[Scope]]프로퍼티를 현재 EC의 ScopeChain을 1번째 부터 차례로 복사한다.
이로써 현재 EC가 담당하고 있는 스코프가 접근할 수 있는 ScopeChain이 형성된다.</p>
</blockquote>

<h5 id="3-variable-instantiation-실행-1">3. Variable Instantiation 실행</h5>
<blockquote>
  <p>이 단계에서는 전단계에서 이야기한 <strong>비어있는</strong> VO에 프로퍼티와 그에 해당하는 값을 채워주는 작업을 하게 된다. <br />
ScopeChain을 이해했다면 특정 Scope에서 접근가능한 VO가 하나가 아니라는 것을 이해하였을 것이다. <br />
외부에 있는 VO들의 경우 ScopeChain을 통해서 접근이 가능하게 되었고 그러한 VO들은 이미 지금 얘기하고자 하는 3단계 작업이 끝난 상태의 VO이다. <br />
이단계의 경우도 동작하는 순서가 있는데 다음과 같다.</p>
</blockquote>

<h5 id="1-formal-parameter-초기화">1. formal Parameter 초기화</h5>
<h5 id="2-함수선언식-초기화">2. 함수선언식 초기화</h5>
<h5 id="3-변수선언식-초기화">3. 변수선언식 초기화</h5>

<p><br /></p>

<h5 id="1-formal-parameter-초기화-1">1. formal Parameter 초기화</h5>
<blockquote>
  <p>실행 컨텍스트의 첫번째 단계인 비어있는 Activation Object생성단계에서 함수 컨택스트의 경우 <br />
arguments 객체에 인수들이 들어간다고 하였다. <br />
하지만 arguments에 들어가는 인수들은 실제 parameter에 해당하는 변수의 이름과 Mapping이 되지않은 상태이다. <br />
즉, 실제 파라미터 변수의 이름으로 AO에 프로퍼티를 추가하고 그에 대한 값은 arguments에 있는 인수의 값을 할당하는 단계가 <br />
formal Parameter를 초기화 하는 단계이다.</p>
</blockquote>

<h5 id="2-함수선언식-초기화-1">2. 함수선언식 초기화</h5>
<blockquote>
  <p>formal Parameter 초기화가 끝나게 되면 함수선언식에 대한 초기화가 실행된다. <br />
위의 문장을 다른 방식으로 얘기하면 다음과 같다. <br />
“함수선언식을 호이스팅한다.” <br />
글의 도입부에서 얘기한 것처럼 호이스팅은 특별한 기능을 이야기하는 것이 아니다. <br />
단순히 실행컨텍스트가 동작하는 순서일 뿐이다. 
EC가 Cover하는 Block 내부에 있는 코드들 중에서 함수선언식들만을 골라서 AO의 프로퍼티에는 함수의 이름을, <br />
그에 해당하는 값으로는 해당 함수의 Function Object를 할당한다. <br />
추가적으로 Function Object또한 Object이므로 그의 Property로 “[[Scope]]”를 만들고 이 것은 현재 EC의 ScopeChain을 가리키도록 한다. <br />
그렇다면 함수선언식이란 무엇일까? 코드로 살펴보자.</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>function foo() {
    ...
}

var bar = function() {
    ...
}

(function iife() {
    ...
})();
</code></pre>
</div>

<blockquote>
  <p>결과적으로 살펴보면 foo와 bar,iife 모두 함수임은 모두가 알고 있을 것이다. <br />
하지만 여기서 함수 선언식에 해당하는 부분은 foo만 해당하게 된다. <br />
bar와 iife의 경우 함수 표현식이라고 얘기한다. <br />
개인적인 생각으로는 bar의 경우는 함수표현식이라는 표현보다 오히려 변수에 값을 할당하는 것이라고 보는 편이 맞는것 같다. <br />
즉, Variable Instantiation을 하는 과정에서(코드가 실행되기 전) 함수의 선언식에 해당하는 부분이 먼저 AO에 올라가게 되므로 <br />
이 것은 마치 우리가 작성한 코드자체가 맨 위로 들어올려진 것처럼 생각하게 된다. <br />
이것을 호이스팅이라고한다.</p>
</blockquote>

<h5 id="3-변수선언식-초기화-1">3. 변수선언식 초기화</h5>
<blockquote>
  <p>변수선언식의 경우에도 전반적으로 함수선언식을 초기화하는 과정과 동일하다. <br />
하지만 여기서 <strong>초기화</strong>라는 의미를 혼동하지 말아야 한다. <br />
흔히 초기화의 의미를 “변수의 선언과 동시에 값을 할당하는 것” 이라고 생각한다. <br />
물론 틀린 말은 아닌 것이라 생각한다. <br />
하지만 실행 컨텍스트 관점에서의 변수의 초기화의 의미는 조금 다르다. <br />
실제 코드 작성 시 변수의 선언과 그 변수에 값을 할당하는 과정을 한 줄로 작성할 수 있기 때문에 <br />
의미의 혼동이 오는 듯 하다. <br />
하지만 내부적으로는 변수의 선언과 변수에 원하는 값을 할당하는 과정사이에 <strong>변수의 값을 “undefined”로 초기화 하는 과정이 있다.</strong> <br />
실행 컨텍스트의 관점에서 변수선언식의 초기화는 바로 변수의 값을 “undefined”로 초기화하는 것을 이야기한다. <br />
코드로 살펴보자.</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>console.log(a);
var a = 1;
</code></pre>
</div>
<blockquote>
  <p>위 코드의 실행 결과는 “undefined”이다. <br />
만약 변수선언식이 Hoisting 되지 않았다면 “a is not defined” 라는 Reference Error를 출력했을테지만 그렇지 않았다는 것은 a 변수가 호이스팅되었고 <br />
초기화 되었다는 것을 의미한다. <br />
하지만 초기화는 우리가 생각하는 “1”이라는 값을 할당하는 개념의 초기화가 아닌 “undefined”라는 값을 할당하는 초기화이기 때문에 <br />
Console에는 “undefined”가 찍히게 된다.  <br />
함수선언식 초기화 부분에서 다뤘던 bar함수의 경우에도 엄밀히 따지면 호이스팅이 된다고 할 수 있다. <br />
단지 함수 호이스팅이 아니라 bar라는 변수를 undefined 형태로 호이스팅 하였기 때문에 함수자체는 호이스팅이 되지 않는다.</p>
</blockquote>

<h5 id="4-this-value-결정-1">4. This value 결정</h5>
<blockquote>
  <p>Variable Instantiation 이 끝나게 되면 EC내부에서 사용될 this변수에 값을 할당하게 된다. <br />
this에 대해서는 따로 얘기가 필요하다고 생각 되는 부분이므로 ~<del>아직잘몰라서가아니고</del>~ <br />
전역 컨텍스트의 경우 전역객체를, 그리고 내부함수의 경우에도 전역객체를 가리킨다는 것 정도로만 이야기 하겠다.
<a href="http://poiemaweb.com/js-this">참고 링크</a></p>
</blockquote>

<h3 id="클로저">클로저</h3>
<blockquote>
  <p>위에 얘기한 내용을 어느정도 이해했다면 클로저가 동작하는 이유를 이해하는 것은 상당히 쉬워진다. <br />
사실 본인도 클로저가 무엇인지 알고 이를 활용해서 모듈패턴을 적용시킬 수 있다는 것 까지 알고 있다. <br />
하지만 도대체 어떻게 함수가 종료되어 콜 스택에서 빠져나간 뒤에도 해당 스코프에 있는 변수들에 접근할 수 있는지는 도저히 이해할 수 없었다. <br />
하지만 실행 컨텍스트의 관점에서 생각해보면 의외로 간단하다. <br />
앞에서도 얘기한 것처럼 어떤 함수가 실행이 종료되면 스택에 생성되었던 EC가 스택에서 빠지게 된다. <br />
하지만 그 함수 내부에 있던 다른 함수가 외부로 노출이 된다면 그 함수는 부모함수의 수명이 다한 뒤에도 부모함수의 Scope를 접근 할 수 있다는 것이 클로저의 기본 개념이다. <br />
함수의 실행이 완료되면 스택에서 EC가 빠지는 것은 명백한 FACT이다. <br />
하지만 EC는 파기 되지만 EC가 가리키고 있던 AO의 경우에는 조금다르다. <br />
이미 클로저로써 외부로 노출된 자식함수의 EC의 ScopeChain은 부모함수의 AO를 가지고 있을 것이다. <br />
이 경우 자식함수가 유효한 동안은 부모함수의 AO가 삭제되지 않는 형태가 되는데 <br />
이것이 바로 클로저가 우리가 생각했던대로 동작하는 이유라고 할 수 있다. <br />
그리고 부모함수의 AO가 사본형태의 AO가아닌 실제 AO를 그대로 가리키고 있으므로 클로저를 여러번 사용해여 부모함수의 AO에 있던 변수의 값을 지속적으로 증가시키는 등의 작업이 가능하다.</p>
</blockquote>

	  ]]></description>
	</item>

	<item>
	  <title>Spring Controller의 Parameter Annotation</title>
	  <link>/logbook//Spring-Request-Parameter-Annotation</link>
	  <author>SeongJin Kim</author>
	  <pubDate>2017-09-02T01:00:00+09:00</pubDate>
	  <guid>/logbook//Spring-Request-Parameter-Annotation</guid>
	  <description><![CDATA[
	     <h3 id="controller의-parameter">Controller의 Parameter</h3>
<blockquote>
  <p>Controller클래스입장에서 URI요청에 대한 Entry Point (실제 Entry Point는 Controller이전에 수많은 것들을 거쳐오겟지만)는 
그안의 Method에서 시작된다. Method는 request로부터 Data를 취하기 위해서 파라미터를 선언하는데 이게 httpservletrequest부터 시작해서
너무도 많은 Data type이 있다. 단순히 일반 객체를 파라미터로 선언하고 Annotation을 통해 자동으로 들어간다.
어떻게 이게 가능할까? 또 각각 무슨차이가 있을까? 
코드를 보면 대략 이렇다.</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>//HttpServletRequest
public String method(HttpServletRequest request) {
   
}

//@RequestParam
public String method(@RequestParam("id") int id) {
   
}

//@ModelAttribute
public String method(@ModelAttribute Object myObject) {
   
}

//@ResquestBody
public String method(@ResquestBody Object myObject) {
   
}
//@pathvariable
@GetMapping("/{productId}")
public String method(@pathvariable int productId) {
   
}
</code></pre>
</div>
<blockquote>
  <p>먼저 <code class="highlighter-rouge">HttpServletRequest</code>부터 알아보자. <br />
Web에서 클라이언트로 받은 HTTP Request는 단순히 텍스트이다. <br />
서버의 구동환경에 따라서 WAS가 있을수도 있고 WebServer만 있을 수도 있지만 Servlet컨테이너를 포함하고 있는 WAS를 거칠 경우, <br />
ServletRequest인터페이스를 거쳐 HTTP프로토콜에 한해서 HttpServletRequest 인터페이스를 구현한 어떤 객체에 Request정보들이 Parsing되는 듯 하다. <br />
Spring을 거쳐 Controller클래스의 method에 도착했을때는 HttpServletRequest를 파라미터로 선언하게 되면 파싱된 Request정보를 사용할 수 있게 된다. <br />
하지만 Application을 개발하는 Layer에서 특정 Container가 만들어내는 객체를 바로사용하는 것을 지향한다고 한다. <br />
(사실 잘이해가 안되는 부분..)</p>
</blockquote>

<blockquote>
  <p>이후 다른 어노테이션들은 모두 HttpServletRequest를 이용하여 자동으로 일반객체에 파싱을 해주는 역할을 한다. <br />
RequestParam부터 알아보자.    <br />
이 어노테이션이 HTTP의 Get방식에서 QueryString을 취할 때만 사용하는 것으로 알고 있는 사람들이 많다.  <br />
본인도 그랬다. 하지만 이 어노테이션은 HTTP Method에 제한되지 않고 Request내부에서 어노테이션 뒤에 명시한 이름과 같은 name을 가지고 있는 
데이터를 찾아서 파싱해준다.  <br />
쉽게 얘기하면 클라이언트가 서버에게 Request를 보낼때 Content Type을 함께 보낸다.    <br />
Default 값은  <code class="highlighter-rouge">application/x-www-form-urlencoded</code>로 Get방식으로 보낼때 ? 뒤에 붙는 Format가 정확히 같다.
ex) <code class="highlighter-rouge">key=value&amp;key=value</code> <br />
RequestParam은 위와 같은 content type으로 넘어온 데이터들 중에서 Key값과 본인이 찾아야할값이 같은 value를 파싱해줄수 있다.</p>
</blockquote>

<blockquote>
  <p>그렇다면 왜 이 어노테이션을 Post방식에서는 자주 볼수 없는 걸까? 
기본적으로 Post방식은 form을 통해서 전송이 될 것이고 그 Content Type 또한  <code class="highlighter-rouge">application/x-www-form-urlencoded</code>으로 될텐데 말이다.
그 이유는 ModelAttribute 어노테이션에 있다고 본다. 예를 들어 다음과 같은 클래스가 있다고 생각해보자</p>
</blockquote>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
  
    <span class="c1">//getter, setter, constructor...  </span>
<span class="o">}</span>
</code></pre>
</div>

<blockquote>
  <p>클라이언트로 부터 id, name, age를 Post방식으로 받아오고 Content type은 Default일 경우 이를 받아내는 Controller의 함수는 다음과 같다.</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>public String method(@RequestParam("id") int id, 
                     @RequestParam("name") String name),
                     @RequestParam("age") int age)) {
   Member member = new Member();
   member.setId(id);
   member.setName(name);
   member.setAge(age);
}
</code></pre>
</div>
<blockquote>
  <p>꽤 괜찮다고 생각할 수 있다. 하지만 클라이언트로부터 받아오는 데이터가 3개보다 훨씬많을 경우에는 코드가 굉장히 길어진다.
ModelAttribute 어노테이션은 이러한 문제를 본인이 짊어진다.
클래스앞에 @ModelAttribute를 붙이면 선언된 클래스를 하나 생성하여 내부에있는 모든 변수들에게 RequestParam을 한것과 같은 결과를 내어준다.</p>
</blockquote>

<blockquote>
  <p>클라이언트의 요청에 대한 응답이 api형태가 아니고 반드시 새로운 페이지를 redirect하는 서버의 경우, <br />
사실 위의 방법만으로도 거의 해결이 가능했던것 같다. 하지만 페이지 전환없이 ajax와같은 Data만을 요구하는 요청에 대해서는 
보통 Content Type이 Default이기 보다는 <code class="highlighter-rouge">application/json</code>으로 보내게 된다. 
앞에서 말한 것처럼 ModelAttribute와 RequestParam의 경우 <code class="highlighter-rouge">application/x-www-form-urlencoded</code>Type의 데이터만 다룰 수 있기 때문에 <br />
Json 형태로 넘어온 데이터에 대해서는 아무것도 할 수 없다.  그럴 경우 RequestBody를 사용하게 되는데 <br />
여기서 사람들이 잘못 이해하고 있는 부분이 있는 것 같다. <em>RequestBody는 Json을 위한 Parsing Annotation이 아니다.</em> <br />
RequestBody는 뒤에 명시한 Object와 클라이언트로 부터받은 Request의 Body 부분을 완벽하게 1:1 로 매칭시킨다. <br />
RequestBody를 사용한 경우 Spring은 Request로 부터 넘어온 Data를 명시한 Object에 완벽히 Parsing시켜줄 수 있는 Converter를 찾는다.
이러한 Converter들은 HttpMessageConverter 인터페이스를 구현한 구현체들이다.  <code class="highlighter-rouge">application/json</code> 형태로 넘어온 데이터의 경우 
Jackson을 기반으로하는 Converter가 이를 Parsing하여 Object에 그대로 mapping 해줄 수 있다.</p>
</blockquote>

<blockquote>
  <p>그렇다면 @pathvariable은 어떤 경우에 사용할까? <br />
@pathvariable의 사용은 REST API가 등장하면서 자주 사용하게 된 것같다. 사실 REST API를 준수하지 않는다면 RequestParam과 하는 역할이 동일하다.
차이점은 RequestParam의 경우 자신이 Mapping할 데이터를 ?뒤에서 즉, 쿼리스트링 또는 Request의 Body부분에 찾는다.
하지만  @pathvariable의 경우 Request하는 URI안에서 데이터를 찾는다. <br />
그렇기 때문에 @pathvariable은 <code class="highlighter-rouge">@GetMapping("/{productId}")</code>처럼 @XXXMapping 어노테이션과 함께 동작해야한다.
요청을 하는 URI로 부터 특정부분을 Mapping하고자 하는 것이 목적이기 때문에 URI에서 Mapping하고자 하는 부분을 명시를 해주고
파라미터를 통해서 그 부분을 Object에 Parsing할 수 있다.</p>
</blockquote>

<blockquote>
  <p>막상 정리를 하려고하니까 컨트롤러 메소드 파라미터관련해서는 정말 끝이 없는 것 같다. 일단은 이정도만..
<del>쓰다가 느낀거지만 Parsing이랑 Mapping 차이는 뭐지??;;;</del></p>
</blockquote>


	  ]]></description>
	</item>

	<item>
	  <title>Spring FrameWork Injection Type</title>
	  <link>/logbook//Spring-Injection-Type</link>
	  <author>SeongJin Kim</author>
	  <pubDate>2017-09-02T01:00:00+09:00</pubDate>
	  <guid>/logbook//Spring-Injection-Type</guid>
	  <description><![CDATA[
	     <h3 id="injection-종류">Injection 종류</h3>
<p><strong>가장 이해가 잘되었던 Post :</strong> <br />
<a href="http://vojtechruzicka.com/field-dependency-injection-considered-harmful/">Field Dependency Injection Considered Harmful</a></p>
<blockquote>
  <p>Spring이 Bean들을 Injection 하는 방법은 대표적으로 3개이다.</p>
  <ol>
    <li>Setter Injection</li>
    <li>Constructor Injection</li>
    <li>Field Injection</li>
  </ol>
</blockquote>

<blockquote>
  <p>그리고 Spring에서는 지원하지 않는 Injection 방식인 Interface를 활용한 방법이 있다고한다.
코드 예시는 다음과 같다.</p>
</blockquote>

<p>1.Setter Injection</p>
<div class="highlighter-rouge"><pre class="highlight"><code>class MyController {
     private MyService myservice;
     @Autowired
     public setMyservice(Myservice myservice) {
          this.myservice = myservice;
     }
}

</code></pre>
</div>
<p>2.Constructor Injection</p>
<div class="highlighter-rouge"><pre class="highlight"><code>class MyController {    
     private MyService myservice;
     @Autowired
     public MyController(Myservice myservice) {
          this.myservice = myservice;
     }
}

</code></pre>
</div>

<p>3.Field Injection</p>
<div class="highlighter-rouge"><pre class="highlight"><code>class MyController {
     @Autowired
     CategoryService categoryService;
}
</code></pre>
</div>

<blockquote>
  <p>성능상으로는 3가지 방법모드 같다고 판단 된다.
Bean이 Injection 되는 시점이 조금 씩다를뿐</p>
</blockquote>

<blockquote>
  <p>코드의 라인수로만 보면 Field Injection을 사용하는 것이 가장 간단하다.
하지만 Spring에서는 Field Injection사용을 지양할 것을 권유한다.
IntelliJ에서도 Field Injection을 사용하면 Warning Comment가 생긴다.</p>
</blockquote>

<blockquote>
  <p>인터넷을 뒤져봐도 Setter VS Constructor 와 관련된 내용이 많고 Field Injection은 거의 언급조차 되지 않는다.</p>
</blockquote>

<blockquote>
  <p>먼저 Setter와 Constructor Injection차이를 알아보자.</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>1. setter Injection in more readable than constructor injection in Spring configuration file usually applicationContext.xml .   
</code></pre>
</div>

<blockquote>
  <p>setter Injection의 경우 인젝션할 클래스가 함수명에 명시되기때문에 설정파일에서 더 직관적으로 읽을 수 있다
constructor의 경우 설정파일에서 인젝션을 명시한경우 실제 클래스파일을 봐야지만 생성자가 무엇을 주입하는지 알수 있다.
하지만 xml 형태의 설정파일뿐만아니라 Java기반으로 설정하는 방법도 있다. Java파일을 기반으로 설정한다면 Constructor를 통해서도 
쉽게 파악이 가능할 것같다.</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>2. one of the drawback of  setter injection is that it does not ensures dependency Injection. 
which means you may have an object with incomplete dependency. On other hand constructor Injection does not allow you to construct object, until your dependencies are ready.
</code></pre>
</div>

<blockquote>
  <p>Injection 시점과 관련된 이야기인듯하다. 먼저 자바에서 클래스가 만들어지는 시점(Bean이생성되는 시점)에 <code class="highlighter-rouge">New ClassName()</code>을 통해서 클래스의 Constructor가 실행된다.
즉, Constructor를 통해서 injection을 한다면 “Bean생성” == “외부 Bean Injection” 이 성립하게된다. 그렇기 때문에 Constructor Injection은 의존성을 주입하지 않고서는 Bean이 생성될 수 없으므로 
확실한 Injection을 보장한다. <br />
하지만 Setter Injection의 경우, 의존성을 주입받는 Bean의 생성과 이 Bean에 다른 Bean을 주입시키는 과정이 분리되게 된다.
먼저 의존성이 주입되지 않는 Bean을 생성한뒤 Setter함수를 통해서 의존성을 주입하게 된다. 
그렇기 때문에 이방법은 의존성이 주입됐다는 것을 보장할 수가 없다.</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>3. In other words, we can force a user of our class (again, this might be Spring but it could also be a unit test that instantiates your class directly) to instantiate it while passing in arguments.
</code></pre>
</div>

<blockquote>
  <p>이 말이 가장 중요한 말이 것 같다. 사실 1번과 2번이 잘 이해가 안되었었다. ‘어짜피 Spring이 결국에는 똑같은 결과를 내어주는데 이게 무슨 의미가 있는가?’라고 생각했다.
하지만 3번을 읽고 <code class="highlighter-rouge">POJO</code> 와 <code class="highlighter-rouge">Unit Test 에서의 Unit</code>이라는 것의 의미를 조금더 알게 되었다. 
스프링은 자바기반 Framework에 불과 하다. 즉 개발자가 작성한 코드와 Spring framework이 완전히 분리가 될 수 있어야한다.
진정한 UnitTest란 Framework에 의존하지 않는 상태에서 Test가 되야한다.</p>
</blockquote>

<p><strong>그렇기 때문에 Feild Injection을 사용한다면 개발자가 작성한 코드가 Spring의 구조에서 벗어나게된다면 Bean을 주입할 코드가 추가로 작성이 되어야한다.</strong></p>

<p>field에 어노테이션을 다는것만으로 Spring은 Injection을 해주지만 실제로는 외부에서 객체를 받는 함수가 존재해야한다.</p>

<p>사실 Spring의 성능상에 차이가 있는 줄알고 찾아봤지만 오히려 뭔가 OOP적인 느낌이 무엇인지 알게 되었다.</p>


	  ]]></description>
	</item>

	<item>
	  <title>BoostCamp2기 wiki</title>
	  <link>/logbook//BoostCamp2-Web-Wiki</link>
	  <author>SeongJin Kim</author>
	  <pubDate>2017-09-02T01:00:00+09:00</pubDate>
	  <guid>/logbook//BoostCamp2-Web-Wiki</guid>
	  <description><![CDATA[
	     <h2 id="boostcamp-2기-web과정-wiki">BoostCamp 2기 Web과정 WIKI</h2>
<blockquote>
  <p>부스트캠프 2기 Web 과정을 수료한 다른팀들 Wiki 입니다.</p>

  <p><a href="https://github.com/Kgwkgwkgw/reservation-system/wiki">네버레스트 팀 Wiki</a> :
Design Pattern<br />
<a href="https://github.com/boostcamp2-gavas/reservation-system/wiki">각자바스 팀 Wiki</a> : 
Spring Security<br />
<a href="https://github.com/Se-yeong/reservation-system/wiki">미사일 팀 Wiki</a> : 
Test<br />
<a href="https://github.com/tjdcks12/reservation-system/wiki">네발자전거 팀 Wiki</a> : 
웹 보안<br />
<a href="https://github.com/BoostCamp2-OZ/reservation-system/wiki">오주의마법사 팀 Wiki</a> : 
웹 성능(Front)<br />
<a href="https://github.com/jungtaejoon/reservation-system/wiki">덩케르크 팀 Wiki</a> : 
웹 MVC, REST<br />
<a href="https://github.com/seokgun88/reservation-system/wiki">YG팀 Wiki</a> : 
ORM : JPA <br />
<a href="https://github.com/boostcamp2-apink/reservation-system/wiki">인간중심팀 Wiki</a> : 
자바스크립트 비동기</p>
</blockquote>

	  ]]></description>
	</item>

	<item>
	  <title>A Full and Comprehensive Style Test</title>
	  <link>/logbook//a-full-and-comprehensive-style-test</link>
	  <author>SeongJin Kim</author>
	  <pubDate>2014-09-27T19:18:00+09:00</pubDate>
	  <guid>/logbook//a-full-and-comprehensive-style-test</guid>
	  <description><![CDATA[
	     <p>This is just an <em>ipsis verbis</em> copy of the first example running on the <a href="http://demo.ghost.io">Ghost Demo</a>. This shows how you can use html styling to achieve your hopes.</p>


<p>Below is just about everything you’ll need to style in the theme. Check the source code to see the many embedded elements within paragraphs.</p>


<hr />

<h1 id="heading1">Heading 1</h1>

<h2 id="heading2">Heading 2</h2>

<h3 id="heading3">Heading 3</h3>

<h4 id="heading4">Heading 4</h4>

<h5 id="heading5">Heading 5</h5>

<h6 id="heading6">Heading 6</h6>

<hr />

<p>Lorem ipsum dolor sit amet, <a title="test link" href="#">test link</a> adipiscing elit. <strong>This is strong.</strong> Nullam dignissim convallis est. Quisque aliquam. <em>This is emphasized.</em> Donec faucibus. Nunc iaculis suscipit dui. 5<sup>3</sup> = 125. Water is H<sub>2</sub>O. Nam sit amet sem. Aliquam libero nisi, imperdiet at, tincidunt nec, gravida vehicula, nisl. <cite>The New York Times</cite> (That’s a citation). <span style="text-decoration:underline;">Underline.</span> Maecenas ornare tortor. Donec sed tellus eget sapien fringilla nonummy. Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus.</p>

<p><abbr title="Hyper Text Markup Language">HTML</abbr> and <abbr title="Cascading Style Sheets">CSS</abbr> are our tools. Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus.  Praesent mattis, massa quis luctus fermentum, turpis mi volutpat justo, eu volutpat enim diam eget metus. To copy a file type <code>COPY <var>filename</var></code>. <del>Dinner’s at 5:00.</del> <ins>Let’s make that 7.</ins> This <span style="text-decoration:line-through;">text</span> has been struck.</p>

<hr />

<h2 id="media">Media</h2>

<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore.</p>

<h3 id="bigimage">Big Image</h3>

<p><img src="http://demo.ghost.io/content/images/2014/09/testimg1.jpeg" alt="Test Image" /></p>

<p>Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.</p>

<h3 id="smallimage">Small Image</h3>

<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore.</p>

<p><img src="http://demo.ghost.io/content/images/2014/09/testimg2.jpg" alt="Small Test Image" /></p>

<p>Labore et dolore.</p>

<hr />

<h2 id="listtypes">List Types</h2>

<h3 id="definitionlist">Definition List</h3>

<dl>  
<dt>Definition List Title</dt>  
<dd>This is a definition list division.</dd>  
<dt>Definition</dt>  
<dd>An exact statement or description of the nature, scope, or meaning of something: <em>our definition of what constitutes poetry.</em></dd>  
</dl>

<h3 id="orderedlist">Ordered List</h3>

<ol>
<li>List Item 1  </li>
<li>List Item 2 <br />
<ol><li>Nested list item A</li>
<li>Nested list item B</li></ol></li>
<li>List Item 3</li>
</ol>

<h3 id="unorderedlist">Unordered List</h3>

<ul>
<li>List Item 1</li>
<li>List Item 2
<ul><li>Nested list item A</li>
<li>Nested list item B</li></ul></li>
<li>List Item 3</li>
</ul>

<hr />

<h2 id="table">Table</h2>

<table>  
<tbody>  
<tr>  
<th>Table Header 1</th>  
<th>Table Header 2</th>  
<th>Table Header 3</th>  
</tr>  
<tr>  
<td>Division 1</td>  
<td>Division 2</td>  
<td>Division 3</td>  
</tr>  
<tr class="even">  
<td>Division 1</td>  
<td>Division 2</td>  
<td>Division 3</td>  
</tr>  
<tr>  
<td>Division 1</td>  
<td>Division 2</td>  
<td>Division 3</td>  
</tr>  
</tbody>  
</table>

<hr />

<h2 id="preformattedtext">Preformatted Text</h2>

<p>Typographically, preformatted text is not the same thing as code. Sometimes, a faithful execution of the text requires preformatted text that may not have anything to do with code. Most browsers use Courier and that’s a good default — with one slight adjustment, Courier 10 Pitch over regular Courier for Linux users.</p>

<h3 id="code">Code</h3>

<p>Code can be presented inline, like <code>&lt;?php bloginfo('stylesheet_url'); ?&gt;</code>, or within a <code>&lt;pre&gt;</code> block. Because we have more specific typographic needs for code, we’ll specify Consolas and Monaco ahead of the browser-defined monospace font.</p>

<p>Code blocks can also be inserted with the highlight tag as below:</p>
<pre>
    
    {% highlight language-x %}
    # some code
    {% endhighlight %}
    
</pre>

<p>More information about code highlighting in jekyll can be found  <a href="https://jekyllrb.com/docs/templates/#code-snippet-highlighting">in Jekyll documentation</a>.</p>

<p>These area a couple of examples showing the resulting highlighted code:</p>

<figure class="highlight"><pre><code class="language-css" data-lang="css"><span class="c">/* css code sample */</span>
<span class="nf">#container</span> <span class="p">{</span>
    <span class="nl">float</span><span class="p">:</span> <span class="nb">left</span><span class="p">;</span>
    <span class="nl">margin</span><span class="p">:</span> <span class="m">0</span> <span class="m">-240px</span> <span class="m">0</span> <span class="m">0</span><span class="p">;</span>
    <span class="nl">width</span><span class="p">:</span> <span class="m">100%</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>


<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// javascript code sample</span>
<span class="nx">$</span><span class="p">.</span><span class="nx">ajax</span><span class="p">({</span>
  <span class="na">type</span><span class="p">:</span> <span class="s1">'POST'</span><span class="p">,</span>
  <span class="na">url</span><span class="p">:</span> <span class="s1">'backend.php'</span><span class="p">,</span>
  <span class="na">data</span><span class="p">:</span> <span class="s2">"q="</span><span class="o">+</span><span class="nx">myform</span><span class="p">.</span><span class="nx">serialize</span><span class="p">(),</span>
  <span class="na">success</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
    <span class="c1">// on success use return data here</span>
  <span class="p">},</span>
  <span class="na">error</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">xhr</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">exception</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// if ajax fails display error alert</span>
    <span class="nx">alert</span><span class="p">(</span><span class="s2">"ajax error response type "</span><span class="o">+</span><span class="nx">type</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span></code></pre></figure>

<p>Now you can also use <a href="https://highlightjs.org/">highlight.js</a>.
For more on how to use it and on the available styles check their
<a href="https://highlightjs.org/static/demo/">demo</a> and
<a href="http://highlightjs.readthedocs.org/en/latest/">documentation</a> pages.</p>

<div class="system">
<pre><code class="swift">// Swift code sample
import Foundation

@objc class Person: Entity {
  var name: String!
  var age:  Int!

  init(name: String, age: Int) {
    /* /* ... */ */
  }

  // Return a descriptive string for this person
  func description(offset: Int = 0) -> String {
    return "\(name) is \(age + offset) years old"
  }
}
</code></pre>
</div>


<hr />

<h2 id="blockquotes">Blockquotes</h2>

<p>Let’s keep it simple. Italics are good to help set it off from the body text. Be sure to style the citation.</p>

<blockquote>
  <p>Good afternoon, gentlemen. I am a HAL 9000 computer. I became operational at the H.A.L. plant in Urbana, Illinois on the 12th of January 1992. My instructor was Mr. Langley, and he taught me to sing a song. If you’d like to hear it I can sing it for you. <cite>— <a href="http://en.wikipedia.org/wiki/HAL_9000">HAL 9000</a></cite></p>
</blockquote>

<p>And here’s a bit of trailing text.</p>

<hr />

<h2 id="textlevelsemantics">Text-level semantics</h2>

<p>The <a href="#">a element</a> example <br />
The <abbr>abbr element</abbr> and <abbr title="Title text">abbr element with title</abbr> examples <br />
The <b>b element</b> example <br />
The <cite>cite element</cite> example <br />
The <code>code element</code> example <br />
The <del>del element</del> example <br />
The <dfn>dfn element</dfn> and <dfn title="Title text">dfn element with title</dfn> examples <br />
The <em>em element</em> example <br />
The <i>i element</i> example <br />
The <ins>ins element</ins> example <br />
The <kbd>kbd element</kbd> example <br />
The <mark>mark element</mark> example <br />
The <q>q element <q>inside</q> a q element</q> example <br />
The <s>s element</s> example <br />
The <samp>samp element</samp> example <br />
The <small>small element</small> example <br />
The <span>span element</span> example <br />
The <strong>strong element</strong> example <br />
The <sub>sub element</sub> example <br />
The <sup>sup element</sup> example <br />
The <var>var element</var> example <br />
The <u>u element</u> example</p>

<hr />

<h2 id="forms">Forms</h2>

<form>  
<fieldset>  
<legend>Inputs as descendents of labels (form legend)</legend>  
<label>  
<b>Text input</b>  
<input type="text" value="default value">  
</label>  
<label>  
<b>Email input</b>  
<input type="email">  
</label>  
<label>  
<b>Search input</b>  
<input type="search">  
</label>  
<label>  
<b>Tel input</b>  
<input type="tel">  
</label>  
<label>  
<b>URL input</b>  
<input type="url" placeholder="http://">  
</label>  
<label>  
<b>Password input</b>  
<input type="password" value="password">  
</label>  
<label>  
<b>File input</b>  
<input type="file">  
</label>  
<label>  
<b>Radio input</b>  
<input type="radio" name="rad">  
</label>  
<label>  
<b>Checkbox input</b>  
<input type="checkbox">  
</label>  
<label>  
<input type="radio" name="rad"> Radio input  
</label>  
<label>  
<input type="checkbox"> Checkbox input  
</label>  
<label>  
<b>Select field</b>  
<select>  
<option>Option 01</option>  
<option>Option 02</option>  
</select>  
</label>  
<label>  
<b>Textarea</b>  
<textarea cols="30" rows="5" >Textarea text</textarea>  
</label>  
</fieldset> 

<fieldset>  
<legend>Clickable inputs and buttons</legend>  
<input type="image" src="http://placekitten.com/90/24" alt="Image (input)">  
<input type="reset" value="Reset (input)">  
<input type="button" value="Button (input)">  
<input type="submit" value="Submit (input)">  
<button type="reset">Reset (button)</button>  
<button type="button">Button (button)</button>  
<button type="submit">Submit (button)</button>  
</fieldset> 

<fieldset id="boxsize">  
<legend>box-sizing tests</legend>  
<div><input type="text" value="text"></div>  
<div><input type="email" value="email"></div>  
<div><input type="search" value="search"></div>  
<div><input type="url" value="http://example.com"></div>  
<div><input type="password" value="password"></div> 

<div><input type="color" value="#000000"></div>  
<div><input type="number" value="5"></div>  
<div><input type="range" value="10"></div>  
<div><input type="date" value="1970-01-01"></div>  
<div><input type="month" value="1970-01"></div>  
<div><input type="week" value="1970-W01"></div>  
<div><input type="time" value="18:23"></div>  
<div><input type="datetime" value="1970-01-01T00:00:00Z"></div>  
<div><input type="datetime-local" value="1970-01-01T00:00"></div> 

<div><input type="radio"></div>  
<div><input type="checkbox"></div> 

<div><select><option>Option 01</option><option>Option 02</option></select></div>  
<div><textarea cols="30" rows="5" >Textarea text</textarea></div> 

<div><input type="image" src="http://placekitten.com/90/24" alt="Image (input)"></div>  
<div><input type="reset" value="Reset (input)"></div>  
<div><input type="button" value="Button (input)"></div>  
<div><input type="submit" value="Submit (input)"></div> 

<div><button type="reset">Reset (button)</button></div>  
<div><button type="button">Button (button)</button></div>  
<div><button type="submit">Submit (button)</button></div>  
</fieldset>  
</form>

<hr />

<h2 id="embeds">Embeds</h2>

<p>Sometimes all you want to do is embed a little love from another location and set your post alive.</p>

<h3 id="video">Video</h3>

<p>Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>

<iframe src="//player.vimeo.com/video/103224792?title=0&amp;byline=0&amp;portrait=0" width="600" height="338" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

<p>Culpa qui officia deserunt mollit anim id est laborum.</p>

<h3 id="slides">Slides</h3>

<p>Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>

<script async class="speakerdeck-embed" data-id="34d2856027ce01316b5d621ab8e7d421" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>

<p>Culpa qui officia deserunt mollit anim id est laborum.</p>

<h3 id="audio">Audio</h3>

<p>Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>

<iframe width="100%" height="450" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/169381837&amp;auto_play=false&amp;hide_related=false&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false&amp;visual=true"></iframe>

<p>Culpa qui officia deserunt mollit anim id est laborum.</p>

<h3 id="code">Code</h3>

<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt.</p>

<p><div data-height="268" data-theme-id="0" data-slug-hash="bcqhe" data-default-tab="js" data-user="rglazebrook" class='codepen'></p>

<pre><code>var c = new Sketch.create({autoclear: false}),
    bigCircle = 50,
    littleCircle = 5,
    // The velocity value determines how much to move the spinner head (in radians).
    velocity = 0.105,
    hue = 0,
    // The alpha value below determines the length of the spinner&#39;s tail.
    bg = &#39;rgba(40,40,40,.075)&#39;;
    Spinner = function() {};

Spinner.prototype.setup = function() {
  this.x = c.width / 2;
  this.y = c.height / 2 - bigCircle;
  this.rotation = 0;
}
Spinner.prototype.update = function() {
  this.rotation += velocity;
  this.rotation = this.rotation % TWO_PI;
  this.x = c.width /2 + cos(this.rotation) * bigCircle;
  this.y = c.height / 2 + sin(this.rotation) * bigCircle;
}
Spinner.prototype.draw = function() {
  c.fillStyle = &#39;hsl(&#39;+hue+&#39;,50%,50%)&#39;;
  c.beginPath();
  c.arc(this.x, this.y, littleCircle, 0, TWO_PI);
  c.fill();
  c.closePath(); 
}
c.setup = function() {
  spinner = new Spinner();
  spinner.setup();
} 
c.update = function() {
  spinner.update();
  hue = ++hue % 360;
}
c.draw = function() {
  spinner.draw();
  c.fillStyle = bg;
  c.fillRect(0,0,c.width,c.height);
}
</code></pre>  

<p>See the Pen <a href='http://codepen.io/rglazebrook/pen/bcqhe/'>Simple Rotating Spinner</a> by Rob Glazebrook (<a href='http://codepen.io/rglazebrook'>@rglazebrook</a>) on <a href='http://codepen.io'>CodePen</a>.</p>  

<p></div><script async src="//codepen.io/assets/embed/ei.js"></script></p>

<p>Isn't it beautiful?</p>
	  ]]></description>
	</item>


</channel>
</rss>
