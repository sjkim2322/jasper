<!DOCTYPE html>
<html>
<head>
    <!-- [[! Document Settings ]] -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- [[! Page Meta ]] -->
    <title>Javascript Hoisting 과 Execution Context</title>
    <meta name="description" content="SeongJin`s LogBook - " />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="/logbook/assets/images/favicon.ico" >

    <!-- [[! Styles'n'Scripts ]] -->
    <link rel="stylesheet" type="text/css" href="/logbook/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css"
          href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/logbook/assets/css/syntax.css" />

    <!-- [[! highlight.js ]] -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- [[! Ghost outputs important style and meta data with this tag ]] -->
        <link rel="canonical" href="/logbook/" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/logbook/page2/" />

    <meta property="og:site_name" content="SeongJin`s LogBook" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="SeongJin`s LogBook" />
    <meta property="og:description" content="" />
    <meta property="og:url" content="/logbook/" />
    <meta property="og:image" content="/logbook/assets/images/cover1.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="SeongJin`s LogBook" />
    <meta name="twitter:description" content="" />
    <meta name="twitter:url" content="/logbook/" />
    <meta name="twitter:image:src" content="/logbook/assets/images/cover1.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "Finding The Way Home",
    "url": "/logbook/",
    "image": "/logbook/assets/images/cover1.jpg",
    "description": ""
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="SeongJin`s LogBook" href="/logbook/feed.xml" />


</head>
<body class="home-template nav-closed">

    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/logbook/">Home</a></li>
        <!--<li class="nav-about " role="presentation"><a href="/logbook/about">About</a></li>-->
        <li class="nav-fables " role="presentation"><a href="/logbook/tag/fables">Fables</a></li>
        <li class="nav-speeches " role="presentation"><a href="/logbook/tag/speeches">Speeches</a></li>
        <li class="nav-fiction " role="presentation"><a href="/logbook/tag/fiction">Fiction</a></li>
        <li class="nav-author " role="presentation"><a href="/logbook/author/casper">Author</a></li>
        <li class="nav-boost " role="presentation"><a href="/logbook/tag/boost">BoostCamp 2기</a></li>
        <li class="nav-spring " role="presentation"><a href="/logbook/tag/spring">Spring</a></li>
        <li class="nav-javascript " role="presentation"><a href="/logbook/tag/javascript">Javascript</a></li>
        <li class="nav-java " role="presentation"><a href="/logbook/tag/java">Java</a></li>
    </ul>
    <!--<a class="subscribe-button icon-feed" href="/logbook/feed.xml">Subscribe</a>-->
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- [[! Everything else gets inserted here ]] -->
        <!-- < default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head " style="background-image: url(/logbook/assets/images/cover6.jpg) ">
    <nav class="main-nav  overlay  clearfix">
        <a class="blog-logo" href="/logbook/"><img src="/logbook/assets/images/logbook.png" alt="Blog Logo" /></a>
        
            <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
        
    </nav>
</header>

<main class="content" role="main">

    <article class="post tag-javascript">

        <header class="post-header">
            <h1 class="post-title">Javascript Hoisting 과 Execution Context</h1>
            <section class="post-meta">
            <!-- <a href='/logbook/'>SeongJin Kim</a> -->
            <time class="post-date" datetime="2017-09-02">03 Sep 2017</time>
                <!-- [[tags prefix=" on "]] -->
                 
                on 
                
                    
                       <a href='/logbook/tag/boost'>Boost</a>,
                       
                
                    
                       <a href='/logbook/tag/javascript'>Javascript</a>
                       
                
                
            </section>
        </header>

        <section class="post-content">
            
            <p><br />
 사실 본인은 자바스크립트가 꽤나 근본이 없는 언어라고 생각했다. <br />
<del>아무렇게 작성해도 알아먹으니까.</del> <br />
특히나 Hoisting가 관련된 부분은 꽤 골머리를 썩혔다. 잘동작했던 코드였는데 잘되다가 안되다가..
그 당시에는 괜히 자바스크립트를 탓했었다. <br />
하지만 그러한 이유는 본인에 무지함에 있었다는 것을 Hoisting을 이해한 뒤로 알게 되었다. <br />
이 글을 읽고 내글의 제목에 Execution Context를 추가했다. Hoisting만 얘기하기에는 설명이 부족할 것같다.
<a href="http://poiemaweb.com/js-execution-context">한글로 제일 잘 설명된 Execution Context 관련 글</a>이라 생각한다.</p>

<h4 id="hoisting의-오해">Hoisting의 오해</h4>

<h5 id="1">1.</h5>
<p>Hoist 라는 단어의 뜻(들어올리다)이 그렇듯, 특정 코드를 가장위로 들어올려주는 것으로 생각한다.
하지만 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting">Mozila</a>에 쓰여진 바로는 다음과 같다.</p>

<ul>
  <li>hoisting teaches that variable and function declarations are physically moved to the top of your coding, 
but this is not what happens at all. What does happen is that variable and function declarations are put into memory during the compile phase,
but stays exactly where you typed it in your coding.</li>
</ul>

<p>즉, Hoisting이라는 것은 우리가 작성한 코드의 물리적 위치를 변경하지 않는다. 단순히 선언식을 먼저 가지고 있는 것일 뿐</p>

<h5 id="2">2.</h5>
<p>Hoisting이라는 것이 자바스크립트가 사용하는 특별한 기능을 지칭하는 말이 아니다. <br />
자바스크립트가 코드를 읽는 방식을 이해한다면 지극히 당연한 기능이지만 코드를 작성하는 입장(Java나 C를 먼저 접한사람이라면)에서는 꽤나 어색하게 느껴진다.
그렇다면 도대체 Hoisting이 뭘까? 자세히 알아보자</p>

<h4 id="실행-컨텍스트">실행 컨텍스트</h4>
<p>사실 Hoisting 뿐만 아니라 클로저,Scope 더 나아가 ES6의 Generator 까지 실행 컨텍스트를 이해하면 모든 의문이 풀린다.
앞에서 얘기한 링크를 많이 참고하였다.       <br />
실행 컨텍스트(이하 EC)란 자바스크립트 코드를 실제로 <strong>실행 시키기 전</strong>에 실행에 필요한 정보를 담고 있는 객체이다.    <br />
최초 글로벌 EC를 필두로 함수가 호출될때마다 함수EC가 스택에 차례로 쌓이게 된다.       <br />
Active Context(현재 활성화된 컨텍스트)는 모든 시점에서 정확히 1개이다. =&gt; 엔진 콜스택의 최상단        <br />
<u>함수 종료시 해당함수의 EC는 파기되고 스택에서도 사라진다.</u>    <br />
그리고 해당함수를 호출한 컨텍스트가 Active Context가 된다. <br />
ES6에 추가된 Generator함수의 경우 위의 밑줄 친 문장은 예외가 된다.    <br />
Yield를 통해 함수의 컨텍스트를 빠져나가게 되는데 이 때 Generator함수의 EC는 파기 되지 않고 현재 상태를 기억하고 있다.      <br />
자세한 내용은 <a href="https://www.ecma-international.org/ecma-262/6.0/#sec-execution-contexts">ECMA 명세</a>를 다시한번 읽어봐야할 듯하다. <br />
<del>한번 읽어봤는데 잘모르겟다 영어를못해서..</del></p>

<blockquote>
  <p>앞서 얘기했듯이 EC는 객체이다. 객체이기 때문에 다음 3가지를 Property로 갖는다.</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>//ExecutionContext
{
    VariableObject : "",
    ScopeChain : "",
    thisValue :""
}
</code></pre>
</div>

<h5 id="1variable-object-이하-vo">1.Variable Object (이하 VO)</h5>

<blockquote>
  <p>실행에 필요한 실제 변수들을 담고 있는 객체를 가리키는 객체이다. <br />
최초에 생성되는 전역 EC의 경우 VO프로퍼티는 전역객체(Global Object 이하 GO)를 가리킨다.     <br />
GO는 전역으로 선언된 함수와 변수를 프로퍼티로 갖는 객체이다. <br />
GO의 경우 모든 Scope에서 접근이 가능하다(Global 객체이므로) <br />
그래서 Built-in object(Math, String, Array 등)와 BOM, DOM이 Set 되어있다.
그리고 전역 Scope에 있는 함수와 변수 선언을 포함하고 있다.</p>
</blockquote>

<blockquote>
  <p>전역코드 뿐만 아니라 함수가 자바스크립트의 CallStack에 들어올때(함수가 호출되어 실행될 때) 또한 EC가 하나생성되고 VO가 생성된다. <br />
함수의 경우, 전역 EC와 달리 VO는 전역객체를 가리키지 않고 Activation Object를 가리키게 된다.
Activation Object의 경우 앞에서 얘기한 GO와 거의 동일하지만 <br />
<u>Built-in object를 포함한 전역객체만의 프로퍼티들</u>을 포함하지 않고 <br />
대신 함수의 인자를 배열형태로 담고 있는 <u>Argument Object</u>가 추가된다.
Argument Object는 함수를 선언시 설정한 파라미터들과는 별개로 보는게 맞는 것같다.</p>
  <div class="highlighter-rouge"><pre class="highlight"><code>function foo(var1,var2,var3) {
    ...
}
foo(1,2,3,4); // thisLine
</code></pre>
  </div>
  <p>다음과 같은 코드의 경우 <code class="highlighter-rouge">thisLine</code> 에서 함수가 callStack에 들어가게 되고 EC가 생성되는데 <br />
함수가 선언될 때는 파라미터를 총 3개를 받지만 호출시에는 총 4개의 인자를 넘겨준다. <br />
이런 경우, 자바같은 경우는 컴파일 에러가 나는 것으로 알고 있지만 <br />
자바스크립트의 경우 그대로 실행되며 여기서 EC가 생성되고 AO에 Argument Object가 생성될때 <br />
그 배열의 길이는 총 4개가 된다. 물론 초기에 선언해둔 변수에 Mapping되는 것은 1,2,3뿐이지만 <br />
AO에는 생성이 되었기 때문에 arguments 오브젝트에 접근해서 값을 사용할 수 있다.
AO에 Argument Object가 생성된 이후로는 GO와 동일한 형태로 현재 Scope에 새롭게 추가된 변수,함수 선언을 AO에 담는다.</p>
</blockquote>

<h5 id="2scopechain">2.ScopeChain</h5>
<blockquote>
  <p>자바나 C를 먼저 공부했던 본인의 입장에서는 ScopeChain은 너무나도 당연한 것이 였지만 <br />
자바스크립트에서는 ScopeChain의 열할이 단순히 상위 스코프를 연결해주는것에서 그치지 않는다는 것이다.
기본적으로 ScopeChain 프로퍼티는 배열이고, 0 번째 Index에서는 현재 EC에서 최초로 생성된 AO를 가리킨다. <br />
1번째 Index는 현재 EC의 상위 컨텍스트에 있는 EC의 AO를 가리킨다. <br />
이런식으로 마지막에는 전역 EC의 GO까지 배열에 담기게 된다. <br />
이러한 ScopeChain 때문에 현재 Scope의 상위에 있는 모든 변수와 함수들에게서 접근을 할 수 있게 된다. <br />
즉, 변수와 함수의 호출이 실행될 경우 그 이름과 일치하는 프로퍼티를 ScopeChain의 0번째 index에서 부터 차례대로 <br />
GO까지 탐색을 하는 과정을 거친다. <br />
(개인적인 생각으로는 EC를 생성하는 시점에 컨텍스트를 타고 타고 올라가는 과정을 거치지는 않을것같다. <br />
현재 AO를 0번째 인덱스에 담고 그이후로는 상위컨텍스트의 ScopeChain을 그대로 덮어쓰지 않을까 싶다.)
또, 이 ScopeChain은 [[Scope]]라는 프로퍼티로 접근이 가능하다.</p>
</blockquote>

<h5 id="3thisvalue">3.thisValue</h5>
<blockquote>
  <p>우리가 코드를 작성하면서 this라는 변수를 사용할 수 있었던 이유는 바로 EC가 this라는 프로퍼티를 생성하기 때문이다. <br />
this의 값은 함수의 호출패턴에 의해 결정된다고한다.(???)</p>
</blockquote>

<p>그런데 왜 본인은 Hoisting을 이야기하다가 갑자기 실행 컨텍스트를 이야기하고 있는가? <br />
사실 앞에서도 얘기 한 것처럼 Hoisting이라는 것은 뭔가 특별한 기능을 뜻하지 않는다고 했다.
단순히 실행컨텍스트의 동작방식을 이해하게 된다면 Hoisting뿐만 아니라 클로저도 이해를 할 수 있다.
그렇다면 EC가 위에 언급한 3개의 프로퍼티를 가지고 어떤식으로 동작하는지 알아보자.</p>

<h4 id="실행컨텍스트의-생성과-동작-방식">실행컨텍스트의 생성과 동작 방식</h4>
<p>실행 컨텍스트는 script코드가 최초에 실행될 때 처음으로 한개 생성된다. <br />
브라우저의 경우 여기서 생성된 전역 컨텍스트는 함수가 종료되었을때 파기되는 다른 EC와달리 페이지가 전환되기 전까지 살아 있다.
앞서 얘기한 것처럼 전역 컨텍스트의 경우 VO에 매핑되는 Object가 다른함수들과 달리 Global Object가 매핑된다고 하였지만
우리가 작성한 코드가 Window이라는 모든 코드를 포함하고 있는 큰함수가 덮고 있다고 생각하면 일반적인 함수의 EC와 같다. <br />
즉, Global Object는 Window이라는 모든 코드를 포함하는 함수의 Activation Object이다.</p>

<p>실행컨텍스트가 동작하는 순서는 다음과 같다.</p>
<h5 id="1-비어있는-activation-object-생성">1. <strong>비어있는</strong> Activation Object 생성</h5>
<h5 id="2-scopechain-생성-및-초기화">2. ScopeChain 생성 및 초기화</h5>
<h5 id="3-variable-instantiation-실행">3. Variable Instantiation 실행</h5>
<h5 id="4-this-value-결정">4. This value 결정</h5>

<p>맨위에 언급한 글에서는 ScopeChain 생성이 가장 먼저로 언급되어 있지만 그전에 빈 AO의 생성이 이루어져야 한다.
빈 AO를 생성하는 것은 실행컨텍스트의 열할이 아니므로 언급이 안된 것 같지만 이해를 위해 첫번째에 생성이 된다고 작성하였다.</p>

<h5 id="1비어있는-activation-object-생성">1.<strong>비어있는</strong> Activation Object 생성</h5>
<blockquote>
  <p>여기서 중요한 것은 <strong>비어있는</strong> 이다. <br />
추후 AO에 모든 변수,함수 선언들이 담길예정이지만 초기에는 비어있는 상태로 생성이 되게 된다. <br />
하지만 Global인 경우 완전히 비어있는 것은 아니고 위에 얘기한 것처럼 Built in Object를 포함한 것들이 생성되어 들어있다. <br />
함수 EC의 Activation Object의 경우에도 완벽히 비어있지는 않다. 함수의 EC가 생성되는 시점은 그 함수가 호출된 시점이므로 <br />
여기서 arguments객체가 생성된다. 함수에 전달된 인수가 하나도없을지라도 arguments객체는 생성된다.(이객체의 property로 callee,symbol,length 등이 생성된다.) <br />
즉, “비어있다”라는 의미는 곧 실행될 Variable Instantiation이 실행되지 않았다는 정도로 이해하는 것이 좋을 듯하다.</p>
</blockquote>

<h5 id="2scopechain-생성-및-초기화">2.ScopeChain 생성 및 초기화</h5>
<blockquote>
  <p>ScopeChain의 생성이 이 시점에서 이루어지는 것은 꽤나 중요하게 생각해야할 부분이다.
함수가 호출되기 전에, 심지어는 3번의 Variable Instantiation이 수행되기 전에 <br />
ScopeChain이 생성되고 초기화가 일어난다는 것은 <br />
어떤 Scope(함수이거나 글로벌이거나)의 코드들이 실행되기 전에 그 Scope에 접근할 수 있는 범위가 결정된다는 얘기이다.
쉽게 코드로 예를 들어보자.
<strong><a href="https://www.zerocho.com/category/Javascript/post/5741d96d094da4986bc950a0">이 글</a>의 코드를 살짝 수정하였습니다.</strong></p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>var name = 'global';
function wow() { 
  console.log(name); // "global";
}
function say () {
  var name = 'inner';
  console.log(name); // "inner"
  wow();
}
say();
</code></pre>
</div>
<blockquote>
  <p>지극히 당연한 얘기일 수도 있겠지만 위 코드에서 wow함수 내부의 name 변수가 전역의 “global”인 것은 <br />
ScopeChain이 함수가 호출되는 시점이 아닌 생성하는 시점에 형성이 되었기 때문에 wow함수의 ScopeChain에는 <br />
say함수의 VO가 없다.(say함수안에서 단순히 wow함수를 호출만 하였으므로)</p>
</blockquote>

<blockquote>
  <p>다시 ScopeChain 얘기로 돌아와서 1번에서 생성한 AO를 ScopeChain의 0번째에 할당한다. <br />
그리고 현재 EC가 실행되기 전에 그전 컨텍스트에 생성 되있던 VO의 [[Scope]]프로퍼티를 현재 EC의 ScopeChain을 1번째 부터 차례로 복사한다.
이로써 현재 EC가 담당하고 있는 스코프가 접근할 수 있는 ScopeChain이 형성된다.</p>
</blockquote>

<h5 id="3-variable-instantiation-실행-1">3. Variable Instantiation 실행</h5>
<blockquote>
  <p>이 단계에서는 전단계에서 이야기한 <strong>비어있는</strong> VO에 프로퍼티와 그에 해당하는 값을 채워주는 작업을 하게 된다. <br />
ScopeChain을 이해했다면 특정 Scope에서 접근가능한 VO가 하나가 아니라는 것을 이해하였을 것이다. <br />
외부에 있는 VO들의 경우 ScopeChain을 통해서 접근이 가능하게 되었고 그러한 VO들은 이미 지금 얘기하고자 하는 3단계 작업이 끝난 상태의 VO이다. <br />
이단계의 경우도 동작하는 순서가 있는데 다음과 같다.</p>
</blockquote>

<h5 id="1-formal-parameter-초기화">1. formal Parameter 초기화</h5>
<h5 id="2-함수선언식-초기화">2. 함수선언식 초기화</h5>
<h5 id="3-변수선언식-초기화">3. 변수선언식 초기화</h5>

<p><br /></p>

<h5 id="1-formal-parameter-초기화-1">1. formal Parameter 초기화</h5>
<blockquote>
  <p>실행 컨텍스트의 첫번째 단계인 비어있는 Activation Object생성단계에서 함수 컨택스트의 경우 <br />
arguments 객체에 인수들이 들어간다고 하였다. <br />
하지만 arguments에 들어가는 인수들은 실제 parameter에 해당하는 변수의 이름과 Mapping이 되지않은 상태이다. <br />
즉, 실제 파라미터 변수의 이름으로 AO에 프로퍼티를 추가하고 그에 대한 값은 arguments에 있는 인수의 값을 할당하는 단계가 <br />
formal Parameter를 초기화 하는 단계이다.</p>
</blockquote>

<h5 id="2-함수선언식-초기화-1">2. 함수선언식 초기화</h5>
<blockquote>
  <p>formal Parameter 초기화가 끝나게 되면 함수선언식에 대한 초기화가 실행된다. <br />
위의 문장을 다른 방식으로 얘기하면 다음과 같다. <br />
“함수선언식을 호이스팅한다.” <br />
글의 도입부에서 얘기한 것처럼 호이스팅은 특별한 기능을 이야기하는 것이 아니다. <br />
단순히 실행컨텍스트가 동작하는 순서일 뿐이다. 
EC가 Cover하는 Block 내부에 있는 코드들 중에서 함수선언식들만을 골라서 AO의 프로퍼티에는 함수의 이름을, <br />
그에 해당하는 값으로는 해당 함수의 Function Object를 할당한다. <br />
추가적으로 Function Object또한 Object이므로 그의 Property로 “[[Scope]]”를 만들고 이 것은 현재 EC의 ScopeChain을 가리키도록 한다. <br />
그렇다면 함수선언식이란 무엇일까? 코드로 살펴보자.</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>function foo() {
    ...
}

var bar = function() {
    ...
}

(function iife() {
    ...
})();
</code></pre>
</div>

<blockquote>
  <p>결과적으로 살펴보면 foo와 bar,iife 모두 함수임은 모두가 알고 있을 것이다. <br />
하지만 여기서 함수 선언식에 해당하는 부분은 foo만 해당하게 된다. <br />
bar와 iife의 경우 함수 표현식이라고 얘기한다. <br />
개인적인 생각으로는 bar의 경우는 함수표현식이라는 표현보다 오히려 변수에 값을 할당하는 것이라고 보는 편이 맞는것 같다. <br />
즉, Variable Instantiation을 하는 과정에서(코드가 실행되기 전) 함수의 선언식에 해당하는 부분이 먼저 AO에 올라가게 되므로 <br />
이 것은 마치 우리가 작성한 코드자체가 맨 위로 들어올려진 것처럼 생각하게 된다. <br />
이것을 호이스팅이라고한다.</p>
</blockquote>

<h5 id="3-변수선언식-초기화-1">3. 변수선언식 초기화</h5>
<blockquote>
  <p>변수선언식의 경우에도 전반적으로 함수선언식을 초기화하는 과정과 동일하다. <br />
하지만 여기서 <strong>초기화</strong>라는 의미를 혼동하지 말아야 한다. <br />
흔히 초기화의 의미를 “변수의 선언과 동시에 값을 할당하는 것” 이라고 생각한다. <br />
물론 틀린 말은 아닌 것이라 생각한다. <br />
하지만 실행 컨텍스트 관점에서의 변수의 초기화의 의미는 조금 다르다. <br />
실제 코드 작성 시 변수의 선언과 그 변수에 값을 할당하는 과정을 한 줄로 작성할 수 있기 때문에 <br />
의미의 혼동이 오는 듯 하다. <br />
하지만 내부적으로는 변수의 선언과 변수에 원하는 값을 할당하는 과정사이에 <strong>변수의 값을 “undefined”로 초기화 하는 과정이 있다.</strong> <br />
실행 컨텍스트의 관점에서 변수선언식의 초기화는 바로 변수의 값을 “undefined”로 초기화하는 것을 이야기한다. <br />
코드로 살펴보자.</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>console.log(a);
var a = 1;
</code></pre>
</div>
<blockquote>
  <p>위 코드의 실행 결과는 “undefined”이다. <br />
만약 변수선언식이 Hoisting 되지 않았다면 “a is not defined” 라는 Reference Error를 출력했을테지만 그렇지 않았다는 것은 a 변수가 호이스팅되었고 <br />
초기화 되었다는 것을 의미한다. <br />
하지만 초기화는 우리가 생각하는 “1”이라는 값을 할당하는 개념의 초기화가 아닌 “undefined”라는 값을 할당하는 초기화이기 때문에 <br />
Console에는 “undefined”가 찍히게 된다.  <br />
함수선언식 초기화 부분에서 다뤘던 bar함수의 경우에도 엄밀히 따지면 호이스팅이 된다고 할 수 있다. <br />
단지 함수 호이스팅이 아니라 bar라는 변수를 undefined 형태로 호이스팅 하였기 때문에 함수자체는 호이스팅이 되지 않는다.</p>
</blockquote>

<h5 id="4-this-value-결정-1">4. This value 결정</h5>
<blockquote>
  <p>Variable Instantiation 이 끝나게 되면 EC내부에서 사용될 this변수에 값을 할당하게 된다. <br />
this에 대해서는 따로 얘기가 필요하다고 생각 되는 부분이므로 ~<del>아직잘몰라서가아니고</del>~ <br />
전역 컨텍스트의 경우 전역객체를, 그리고 내부함수의 경우에도 전역객체를 가리킨다는 것 정도로만 이야기 하겠다.
<a href="http://poiemaweb.com/js-this">참고 링크</a></p>
</blockquote>

<h3 id="클로저">클로저</h3>
<blockquote>
  <p>위에 얘기한 내용을 어느정도 이해했다면 클로저가 동작하는 이유를 이해하는 것은 상당히 쉬워진다. <br />
사실 본인도 클로저가 무엇인지 알고 이를 활용해서 모듈패턴을 적용시킬 수 있다는 것 까지 알고 있다. <br />
하지만 도대체 어떻게 함수가 종료되어 콜 스택에서 빠져나간 뒤에도 해당 스코프에 있는 변수들에 접근할 수 있는지는 도저히 이해할 수 없었다. <br />
하지만 실행 컨텍스트의 관점에서 생각해보면 의외로 간단하다. <br />
앞에서도 얘기한 것처럼 어떤 함수가 실행이 종료되면 스택에 생성되었던 EC가 스택에서 빠지게 된다. <br />
하지만 그 함수 내부에 있던 다른 함수가 외부로 노출이 된다면 그 함수는 부모함수의 수명이 다한 뒤에도 부모함수의 Scope를 접근 할 수 있다는 것이 클로저의 기본 개념이다. <br />
함수의 실행이 완료되면 스택에서 EC가 빠지는 것은 명백한 FACT이다. <br />
하지만 EC는 파기 되지만 EC가 가리키고 있던 AO의 경우에는 조금다르다. <br />
이미 클로저로써 외부로 노출된 자식함수의 EC의 ScopeChain은 부모함수의 AO를 가지고 있을 것이다. <br />
이 경우 자식함수가 유효한 동안은 부모함수의 AO가 삭제되지 않는 형태가 되는데 <br />
이것이 바로 클로저가 우리가 생각했던대로 동작하는 이유라고 할 수 있다. <br />
그리고 부모함수의 AO가 사본형태의 AO가아닌 실제 AO를 그대로 가리키고 있으므로 클로저를 여러번 사용해여 부모함수의 AO에 있던 변수의 값을 지속적으로 증가시키는 등의 작업이 가능하다.</p>
</blockquote>


        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->

            
            <figure class="author-image">
                <a class="img" href="/logbook/author/sjkim2322" style="background-image: url(/logbook/assets/images/profile.png)"><span class="hidden">'s Picture</span></a>
            </figure>
            

            <section class="author">
                <h4><a href="/logbook/author/sjkim2322">SeongJin Kim</a></h4>
                
                
                    <p> </p>
                
                <div class="author-meta">
                    <span class="author-location icon-location"> Seoul, Korea</span> 
                    <span class="author-link icon-link"><a href="http://sjkim2322.github.io/logbook/"> sjkim2322.github.io/logbook/</a></span> 
                </div>
            </section>

            <!-- /author  -->

            <section class="share">
                <h4>Share this post</h4>
                <a class="icon-twitter" href="http://twitter.com/share?text=Javascript Hoisting 과 Execution Context&amp;url=http://sjkim2322.github.io/logbook/Javascript-Hoisting"
                    onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <span class="hidden">Twitter</span>
                </a>
                <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://sjkim2322.github.io/logbook/Javascript-Hoisting"
                    onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <span class="hidden">Facebook</span>
                </a>
                <a class="icon-google-plus" href="https://plus.google.com/share?url=http://sjkim2322.github.io/logbook/Javascript-Hoisting"
                   onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <span class="hidden">Google+</span>
                </a>
            </section>
            
            <!-- Add Disqus Comments -->
            
            
        </footer>

    </article>

</main>

<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story " style="background-image: url(/logbook/assets/images/cover6.jpg)" href="/logbook/Spring-Join-Integer-Wiki">
            <section class="post">
                <h2>Spring Jdbc의 join과 Integer</h2>
                <p>Join과 Integer라니 글의 주제가 꽤나 Matching되지 않아 보인다. 하지만 본인이 개발하면서 저 2가지의 개념사이에 연결부분이...</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev " style="background-image: url(/logbook/assets/images/cover6.jpg)" href="/logbook/Spring-Request-Parameter-Annotation">
            <section class="post">
                <h2>Spring Controller의 Parameter Annotation</h2>
                <p>Controller의 Parameter Controller클래스입장에서 URI요청에 대한 Entry Point (실제 Entry Point는 Controller이전에 수많은 것들을 거쳐오겟지만)는 그안의...</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/logbook/">SeongJin`s LogBook</a> &copy; 2017</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/biomadeira/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- [[! Ghost outputs important scripts and data with this tag ]] -->
    <script type="text/javascript" src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
    <!-- [[! The main JavaScript file for Casper ]] -->
    <script type="text/javascript" src="/logbook/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="/logbook/assets/js/index.js"></script>

    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-69281367-1', 'auto');
	    ga('send', 'pageview');

     </script>   
</body>
</html>
